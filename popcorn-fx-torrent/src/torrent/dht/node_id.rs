use crate::torrent::dht::{Error, Result};
use crc::{Crc, CRC_32_ISCSI};
use rand::{rng, Rng, RngCore};
use serde::{Deserialize, Deserializer, Serialize, Serializer};
use sha1::{Digest, Sha1};
use std::fmt::{Debug, Display, Formatter};
use std::net::{IpAddr, SocketAddr};
use std::result;

const NODE_ID_SIZE: usize = 20;
const MAX_DISTANCE: u8 = NODE_ID_SIZE as u8 * 8; // = 160
const CRC32: Crc<u32> = Crc::<u32>::new(&CRC_32_ISCSI);

/// The unique DHT node identifier.
#[derive(Copy, Clone, PartialEq)]
pub struct NodeId([u8; NODE_ID_SIZE]);

impl NodeId {
    /// Generate a random node id.
    pub fn new() -> Self {
        let mut random_bytes = [0u8; NODE_ID_SIZE];
        rand::rng().fill_bytes(&mut random_bytes);

        let hash = Sha1::digest(&random_bytes);
        let mut node_id = [0u8; NODE_ID_SIZE];
        node_id.copy_from_slice(hash.as_ref());
        Self(node_id)
    }

    /// Create a new node id from the given address.
    /// It uses a random generated byte for hashing the ip address.
    /// See BEP42 for more info.
    ///
    /// If you want to use a fixed byte for hashing, use [Self::from_ip_with_rand] instead.
    pub fn from_ip(addr: &SocketAddr) -> Self {
        Self::from_ip_with_rand(addr, rng().random::<u8>())
    }

    /// Create a new node id from the given ip address using a fixed `rand` for hashing.
    /// See BEP42 for more info.
    ///
    /// # Arguments
    ///
    /// * `addr` - The IP address create a new node id for.
    /// * `rand` - The random byte to use for hashing the ip address.
    pub fn from_ip_with_rand(addr: &SocketAddr, rand: u8) -> Self {
        const IPV4_MASK: [u8; 4] = [0x03, 0x0f, 0x3f, 0xff];
        const IPV6_MASK: [u8; 8] = [0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff];

        let (mut ip_bytes, mask): (Vec<u8>, &[u8]) = match addr.ip() {
            IpAddr::V4(ipv4) => (ipv4.octets().to_vec(), &IPV4_MASK),
            IpAddr::V6(ipv6) => (ipv6.octets()[..8].to_vec(), &IPV6_MASK),
        };

        for (i, m) in mask.iter().enumerate() {
            ip_bytes[i] &= m;
        }

        let r: u8 = rand & 0x7; // only low 3 bits are used of the random byte
        ip_bytes[0] |= r << 5; // insert the 3-bits from `r` into the top bits of ip byte 0

        let ip_hash = CRC32.checksum(&ip_bytes).to_be_bytes();
        let mut id_bytes = [0u8; NODE_ID_SIZE];
        rand::rng().fill_bytes(&mut id_bytes);

        // set the first 21 bits to the ip hash
        id_bytes[0] = ip_hash[0];
        id_bytes[1] = ip_hash[1];
        id_bytes[2] = (ip_hash[2] & 0xf8) | rng().random_range(0..=0x7);

        // update the last byte to the `random_byte` that was used to generate the hash
        id_bytes[19] = rand;

        Self(id_bytes)
    }

    /// Get the slice value of the node id.
    ///
    /// # Returns
    ///
    /// A 20-byte slice representing the node id.
    pub fn as_slice(&self) -> &[u8] {
        &self.0
    }

    /// Get the fixed node slice value of the node id.
    ///
    /// # Returns
    ///
    /// It returns a fixed 20-byte slice representing the node id.
    pub fn as_node_slice(&self) -> &[u8; NODE_ID_SIZE] {
        &self.0
    }

    /// Get the bitwise XOR result between this node and the target node.
    ///
    /// # Returns
    ///
    /// Returns a new node ID based on the bitwise XOR operation.
    pub fn xor(&self, node: &NodeId) -> NodeId {
        let mut result = [0u8; NODE_ID_SIZE];
        for (i, (a, b)) in self.0.iter().zip(node.0).enumerate() {
            result[i] = a ^ b;
        }
        result.into()
    }

    /// Count the number of leading zeros within the binary representation of this id.
    pub fn leading_zeros(&self) -> u8 {
        for (i, byte) in self.0.iter().enumerate() {
            if *byte != 0 {
                return (i as u32 * 8 + byte.leading_zeros()) as u8;
            }
        }

        160
    }

    /// Get the distance between this node and the target node.
    ///
    /// When both nodes are the same, the result will be 0.
    /// When the nodes don't match at all, the result is [MAX_DISTANCE].
    pub fn distance(&self, node: &NodeId) -> u8 {
        MAX_DISTANCE - self.xor(node).leading_zeros()
    }
}

impl Display for NodeId {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", String::from_utf8_lossy(&self.0))
    }
}

impl Debug for NodeId {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", String::from_utf8_lossy(&self.0))
    }
}

impl From<[u8; 20]> for NodeId {
    fn from(value: [u8; 20]) -> Self {
        Self { 0: value }
    }
}

impl From<&[u8; 20]> for NodeId {
    fn from(value: &[u8; 20]) -> Self {
        Self::from(*value)
    }
}

impl TryFrom<&[u8]> for NodeId {
    type Error = Error;

    fn try_from(value: &[u8]) -> Result<Self> {
        let bytes: [u8; 20] = value.try_into().map_err(|_| Error::InvalidNodeId)?;
        Ok(Self { 0: bytes })
    }
}

impl From<&SocketAddr> for NodeId {
    fn from(value: &SocketAddr) -> Self {
        Self::from_ip(value)
    }
}

impl Serialize for NodeId {
    fn serialize<S>(&self, serializer: S) -> result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_bytes(&self.0)
    }
}

impl<'de> Deserialize<'de> for NodeId {
    fn deserialize<D>(deserializer: D) -> result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        Ok(Self::from(&serde_bytes::deserialize::<[u8; 20], D>(
            deserializer,
        )?))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_node_id_new() {
        let result = NodeId::new();

        assert_ne!(
            [0u8; 20], result.0,
            "expected a random node id to have been generated"
        );
    }

    #[test]
    fn test_node_id_as_slice() {
        let mut node_id = [0u8; 20];
        node_id[1] = 10;
        node_id[2] = 20;

        let result = NodeId::from(&node_id);

        assert_eq!(&node_id, result.as_slice());
    }

    #[test]
    fn test_try_from_byte_slice() {
        let node_id = "abcdefghij0123456789";

        let result = NodeId::try_from(node_id.as_bytes()).expect("expected a valid node id");

        assert_eq!(node_id.as_bytes(), result.as_slice());
    }

    mod from_ip {
        use super::*;

        #[test]
        fn test_from_ip_rand_1() {
            let ip = SocketAddr::from(([124, 31, 75, 21], 6881));
            let rand = 1;

            let result = NodeId::from_ip_with_rand(&ip, rand);

            assert_id_prefix(&[0x5f, 0xbf, 0xbf], result.as_slice());
            assert_eq!(
                rand,
                result.as_slice()[19],
                "expected the last byte to match the rand"
            );
        }

        #[test]
        fn test_from_ip_rand_86() {
            let ip = SocketAddr::from(([21, 75, 31, 124], 6881));
            let rand = 86;

            let result = NodeId::from_ip_with_rand(&ip, rand);

            assert_id_prefix(&[0x5a, 0x3c, 0xe9], result.as_slice());
            assert_eq!(
                rand,
                result.as_slice()[19],
                "expected the last byte to match the rand"
            );
        }

        #[test]
        fn test_from_ip_rand_22() {
            let ip = SocketAddr::from(([65, 23, 51, 170], 6881));
            let rand = 22;

            let result = NodeId::from_ip_with_rand(&ip, rand);

            assert_id_prefix(&[0xa5, 0xd4, 0x32], result.as_slice());
            assert_eq!(
                rand,
                result.as_slice()[19],
                "expected the last byte to match the rand"
            );
        }

        fn assert_id_prefix(expected_prefix: &[u8], node_id: &[u8]) {
            assert_eq!(
                expected_prefix[0], node_id[0],
                "expected the first byte to match"
            );
            assert_eq!(
                expected_prefix[1], node_id[1],
                "expected the second byte to match"
            );
            assert_eq!(
                expected_prefix[2] & 0xf8,
                node_id[2] & 0xf8,
                "expected the first 5 bits to match from the 3th byte"
            );
        }
    }

    mod distance {
        use super::*;

        #[test]
        fn test_same_node() {
            let node1 = NodeId::try_from(
                Sha1::digest("ffff740985723049587230495872304958703294").as_slice(),
            )
            .unwrap();
            let node2 = NodeId::try_from(
                Sha1::digest("ffff740985723049587230495872304958703294").as_slice(),
            )
            .unwrap();

            let result = node1.distance(&node2);

            assert_eq!(0, result, "expected the node result to be the same");
        }

        #[test]
        fn test_random_node() {
            let node1 = NodeId::try_from(
                Sha1::digest("ffff740985723049587230495872304958703294").as_slice(),
            )
            .unwrap();
            let node2 = NodeId::new();

            let result = node1.distance(&node2);

            assert_ne!(0, result, "expected the nodes to not match");
        }

        #[test]
        fn test_fartest_distance() {
            let node1 = NodeId::try_from(
                Sha1::digest("ffffffffffffffffffffffffffffffffffffffff").as_slice(),
            )
            .unwrap();
            let node2 = NodeId::try_from(
                Sha1::digest("0000000000000000000000000000000000000000").as_slice(),
            )
            .unwrap();
            let result = node1.distance(&node2);
            assert_eq!(159, result, "expected the nodes to not match");
        }

        #[test]
        fn test_almost_fartest_distance() {
            let node1 = NodeId::try_from(
                Sha1::digest("8000000000000000000000000000000000000000").as_slice(),
            )
            .unwrap();
            let node2 = NodeId::try_from(
                Sha1::digest("fffffffffffffffffffffffffffffffffffffffe").as_slice(),
            )
            .unwrap();
            let result = node1.distance(&node2);
            assert_eq!(158, result);
        }
    }
}
