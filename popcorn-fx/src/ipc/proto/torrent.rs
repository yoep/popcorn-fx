// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by protoc 33.2
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `torrent.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

// @@protoc_insertion_point(message:fx.ipc.proto.Torrent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Torrent {
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.Torrent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Torrent {
    fn default() -> &'a Torrent {
        <Torrent as ::protobuf::Message>::default_instance()
    }
}

impl Torrent {
    pub fn new() -> Torrent {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Torrent {
    const NAME: &'static str = "Torrent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Torrent {
        Torrent::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Torrent {
        static instance: Torrent = Torrent {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `Torrent`
pub mod torrent {
    // @@protoc_insertion_point(message:fx.ipc.proto.Torrent.Info)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Info {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Info.handle)
        pub handle: ::protobuf::MessageField<super::super::message::Handle>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Info.info_hash)
        pub info_hash: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Info.uri)
        pub uri: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Info.name)
        pub name: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Info.directory_name)
        pub directory_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Info.total_files)
        pub total_files: u32,
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Info.files)
        pub files: ::std::vec::Vec<info::File>,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.Torrent.Info.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Info {
        fn default() -> &'a Info {
            <Info as ::protobuf::Message>::default_instance()
        }
    }

    impl Info {
        pub fn new() -> Info {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for Info {
        const NAME: &'static str = "Info";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.handle)?;
                    },
                    18 => {
                        self.info_hash = is.read_string()?;
                    },
                    26 => {
                        self.uri = is.read_string()?;
                    },
                    34 => {
                        self.name = is.read_string()?;
                    },
                    42 => {
                        self.directory_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    48 => {
                        self.total_files = is.read_uint32()?;
                    },
                    58 => {
                        self.files.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.handle.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if !self.info_hash.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.info_hash);
            }
            if !self.uri.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.uri);
            }
            if !self.name.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.name);
            }
            if let Some(v) = self.directory_name.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            if self.total_files != 0 {
                my_size += ::protobuf::rt::uint32_size(6, self.total_files);
            }
            for value in &self.files {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.handle.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if !self.info_hash.is_empty() {
                os.write_string(2, &self.info_hash)?;
            }
            if !self.uri.is_empty() {
                os.write_string(3, &self.uri)?;
            }
            if !self.name.is_empty() {
                os.write_string(4, &self.name)?;
            }
            if let Some(v) = self.directory_name.as_ref() {
                os.write_string(5, v)?;
            }
            if self.total_files != 0 {
                os.write_uint32(6, self.total_files)?;
            }
            for v in &self.files {
                ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Info {
            Info::new()
        }

        fn clear(&mut self) {
            self.handle.clear();
            self.info_hash.clear();
            self.uri.clear();
            self.name.clear();
            self.directory_name = ::std::option::Option::None;
            self.total_files = 0;
            self.files.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Info {
            static instance: Info = Info {
                handle: ::protobuf::MessageField::none(),
                info_hash: ::std::string::String::new(),
                uri: ::std::string::String::new(),
                name: ::std::string::String::new(),
                directory_name: ::std::option::Option::None,
                total_files: 0,
                files: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Info`
    pub mod info {
        // @@protoc_insertion_point(message:fx.ipc.proto.Torrent.Info.File)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct File {
            // message fields
            // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Info.File.index)
            pub index: u32,
            // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Info.File.filename)
            pub filename: ::std::string::String,
            // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Info.File.torrent_path)
            pub torrent_path: ::std::string::String,
            // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Info.File.offset)
            pub offset: u64,
            // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Info.File.length)
            pub length: u64,
            // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Info.File.md5sum)
            pub md5sum: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Info.File.sha1)
            pub sha1: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:fx.ipc.proto.Torrent.Info.File.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a File {
            fn default() -> &'a File {
                <File as ::protobuf::Message>::default_instance()
            }
        }

        impl File {
            pub fn new() -> File {
                ::std::default::Default::default()
            }
        }

        impl ::protobuf::Message for File {
            const NAME: &'static str = "File";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.index = is.read_uint32()?;
                        },
                        18 => {
                            self.filename = is.read_string()?;
                        },
                        26 => {
                            self.torrent_path = is.read_string()?;
                        },
                        32 => {
                            self.offset = is.read_uint64()?;
                        },
                        40 => {
                            self.length = is.read_uint64()?;
                        },
                        50 => {
                            self.md5sum = ::std::option::Option::Some(is.read_string()?);
                        },
                        58 => {
                            self.sha1 = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.index != 0 {
                    my_size += ::protobuf::rt::uint32_size(1, self.index);
                }
                if !self.filename.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.filename);
                }
                if !self.torrent_path.is_empty() {
                    my_size += ::protobuf::rt::string_size(3, &self.torrent_path);
                }
                if self.offset != 0 {
                    my_size += ::protobuf::rt::uint64_size(4, self.offset);
                }
                if self.length != 0 {
                    my_size += ::protobuf::rt::uint64_size(5, self.length);
                }
                if let Some(v) = self.md5sum.as_ref() {
                    my_size += ::protobuf::rt::string_size(6, &v);
                }
                if let Some(v) = self.sha1.as_ref() {
                    my_size += ::protobuf::rt::string_size(7, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.index != 0 {
                    os.write_uint32(1, self.index)?;
                }
                if !self.filename.is_empty() {
                    os.write_string(2, &self.filename)?;
                }
                if !self.torrent_path.is_empty() {
                    os.write_string(3, &self.torrent_path)?;
                }
                if self.offset != 0 {
                    os.write_uint64(4, self.offset)?;
                }
                if self.length != 0 {
                    os.write_uint64(5, self.length)?;
                }
                if let Some(v) = self.md5sum.as_ref() {
                    os.write_string(6, v)?;
                }
                if let Some(v) = self.sha1.as_ref() {
                    os.write_string(7, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> File {
                File::new()
            }

            fn clear(&mut self) {
                self.index = 0;
                self.filename.clear();
                self.torrent_path.clear();
                self.offset = 0;
                self.length = 0;
                self.md5sum = ::std::option::Option::None;
                self.sha1 = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static File {
                static instance: File = File {
                    index: 0,
                    filename: ::std::string::String::new(),
                    torrent_path: ::std::string::String::new(),
                    offset: 0,
                    length: 0,
                    md5sum: ::std::option::Option::None,
                    sha1: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }

    // @@protoc_insertion_point(message:fx.ipc.proto.Torrent.Health)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Health {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Health.state)
        pub state: ::protobuf::EnumOrUnknown<health::State>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Health.ratio)
        pub ratio: f32,
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Health.seeds)
        pub seeds: u32,
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Health.leechers)
        pub leechers: u32,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.Torrent.Health.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Health {
        fn default() -> &'a Health {
            <Health as ::protobuf::Message>::default_instance()
        }
    }

    impl Health {
        pub fn new() -> Health {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for Health {
        const NAME: &'static str = "Health";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.state = is.read_enum_or_unknown()?;
                    },
                    21 => {
                        self.ratio = is.read_float()?;
                    },
                    24 => {
                        self.seeds = is.read_uint32()?;
                    },
                    32 => {
                        self.leechers = is.read_uint32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.state != ::protobuf::EnumOrUnknown::new(health::State::UNKNOWN) {
                my_size += ::protobuf::rt::int32_size(1, self.state.value());
            }
            if self.ratio != 0. {
                my_size += 1 + 4;
            }
            if self.seeds != 0 {
                my_size += ::protobuf::rt::uint32_size(3, self.seeds);
            }
            if self.leechers != 0 {
                my_size += ::protobuf::rt::uint32_size(4, self.leechers);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.state != ::protobuf::EnumOrUnknown::new(health::State::UNKNOWN) {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.state))?;
            }
            if self.ratio != 0. {
                os.write_float(2, self.ratio)?;
            }
            if self.seeds != 0 {
                os.write_uint32(3, self.seeds)?;
            }
            if self.leechers != 0 {
                os.write_uint32(4, self.leechers)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Health {
            Health::new()
        }

        fn clear(&mut self) {
            self.state = ::protobuf::EnumOrUnknown::new(health::State::UNKNOWN);
            self.ratio = 0.;
            self.seeds = 0;
            self.leechers = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Health {
            static instance: Health = Health {
                state: ::protobuf::EnumOrUnknown::from_i32(0),
                ratio: 0.,
                seeds: 0,
                leechers: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Health`
    pub mod health {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:fx.ipc.proto.Torrent.Health.State)
        pub enum State {
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Torrent.Health.State.UNKNOWN)
            UNKNOWN = 0,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Torrent.Health.State.BAD)
            BAD = 1,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Torrent.Health.State.MEDIUM)
            MEDIUM = 2,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Torrent.Health.State.GOOD)
            GOOD = 3,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Torrent.Health.State.EXCELLENT)
            EXCELLENT = 4,
        }

        impl ::protobuf::Enum for State {
            const NAME: &'static str = "State";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<State> {
                match value {
                    0 => ::std::option::Option::Some(State::UNKNOWN),
                    1 => ::std::option::Option::Some(State::BAD),
                    2 => ::std::option::Option::Some(State::MEDIUM),
                    3 => ::std::option::Option::Some(State::GOOD),
                    4 => ::std::option::Option::Some(State::EXCELLENT),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<State> {
                match str {
                    "UNKNOWN" => ::std::option::Option::Some(State::UNKNOWN),
                    "BAD" => ::std::option::Option::Some(State::BAD),
                    "MEDIUM" => ::std::option::Option::Some(State::MEDIUM),
                    "GOOD" => ::std::option::Option::Some(State::GOOD),
                    "EXCELLENT" => ::std::option::Option::Some(State::EXCELLENT),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [State] = &[
                State::UNKNOWN,
                State::BAD,
                State::MEDIUM,
                State::GOOD,
                State::EXCELLENT,
            ];
        }

        impl ::std::default::Default for State {
            fn default() -> Self {
                State::UNKNOWN
            }
        }

    }

    // @@protoc_insertion_point(message:fx.ipc.proto.Torrent.Stats)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Stats {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Stats.progress)
        pub progress: f32,
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Stats.upload)
        pub upload: u64,
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Stats.upload_rate)
        pub upload_rate: u64,
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Stats.upload_useful)
        pub upload_useful: u64,
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Stats.upload_useful_rate)
        pub upload_useful_rate: u64,
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Stats.download)
        pub download: u64,
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Stats.download_rate)
        pub download_rate: u64,
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Stats.download_useful)
        pub download_useful: u64,
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Stats.download_useful_rate)
        pub download_useful_rate: u64,
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Stats.total_uploaded)
        pub total_uploaded: u64,
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Stats.total_downloaded)
        pub total_downloaded: u64,
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Stats.total_downloaded_useful)
        pub total_downloaded_useful: u64,
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Stats.wanted_pieces)
        pub wanted_pieces: u64,
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Stats.completed_pieces)
        pub completed_pieces: u64,
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Stats.total_size)
        pub total_size: u64,
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Stats.total_completed_size)
        pub total_completed_size: u64,
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Stats.total_peers)
        pub total_peers: u64,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.Torrent.Stats.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Stats {
        fn default() -> &'a Stats {
            <Stats as ::protobuf::Message>::default_instance()
        }
    }

    impl Stats {
        pub fn new() -> Stats {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for Stats {
        const NAME: &'static str = "Stats";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.progress = is.read_float()?;
                    },
                    16 => {
                        self.upload = is.read_uint64()?;
                    },
                    24 => {
                        self.upload_rate = is.read_uint64()?;
                    },
                    32 => {
                        self.upload_useful = is.read_uint64()?;
                    },
                    40 => {
                        self.upload_useful_rate = is.read_uint64()?;
                    },
                    48 => {
                        self.download = is.read_uint64()?;
                    },
                    56 => {
                        self.download_rate = is.read_uint64()?;
                    },
                    64 => {
                        self.download_useful = is.read_uint64()?;
                    },
                    72 => {
                        self.download_useful_rate = is.read_uint64()?;
                    },
                    80 => {
                        self.total_uploaded = is.read_uint64()?;
                    },
                    88 => {
                        self.total_downloaded = is.read_uint64()?;
                    },
                    96 => {
                        self.total_downloaded_useful = is.read_uint64()?;
                    },
                    104 => {
                        self.wanted_pieces = is.read_uint64()?;
                    },
                    112 => {
                        self.completed_pieces = is.read_uint64()?;
                    },
                    120 => {
                        self.total_size = is.read_uint64()?;
                    },
                    128 => {
                        self.total_completed_size = is.read_uint64()?;
                    },
                    136 => {
                        self.total_peers = is.read_uint64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.progress != 0. {
                my_size += 1 + 4;
            }
            if self.upload != 0 {
                my_size += ::protobuf::rt::uint64_size(2, self.upload);
            }
            if self.upload_rate != 0 {
                my_size += ::protobuf::rt::uint64_size(3, self.upload_rate);
            }
            if self.upload_useful != 0 {
                my_size += ::protobuf::rt::uint64_size(4, self.upload_useful);
            }
            if self.upload_useful_rate != 0 {
                my_size += ::protobuf::rt::uint64_size(5, self.upload_useful_rate);
            }
            if self.download != 0 {
                my_size += ::protobuf::rt::uint64_size(6, self.download);
            }
            if self.download_rate != 0 {
                my_size += ::protobuf::rt::uint64_size(7, self.download_rate);
            }
            if self.download_useful != 0 {
                my_size += ::protobuf::rt::uint64_size(8, self.download_useful);
            }
            if self.download_useful_rate != 0 {
                my_size += ::protobuf::rt::uint64_size(9, self.download_useful_rate);
            }
            if self.total_uploaded != 0 {
                my_size += ::protobuf::rt::uint64_size(10, self.total_uploaded);
            }
            if self.total_downloaded != 0 {
                my_size += ::protobuf::rt::uint64_size(11, self.total_downloaded);
            }
            if self.total_downloaded_useful != 0 {
                my_size += ::protobuf::rt::uint64_size(12, self.total_downloaded_useful);
            }
            if self.wanted_pieces != 0 {
                my_size += ::protobuf::rt::uint64_size(13, self.wanted_pieces);
            }
            if self.completed_pieces != 0 {
                my_size += ::protobuf::rt::uint64_size(14, self.completed_pieces);
            }
            if self.total_size != 0 {
                my_size += ::protobuf::rt::uint64_size(15, self.total_size);
            }
            if self.total_completed_size != 0 {
                my_size += ::protobuf::rt::uint64_size(16, self.total_completed_size);
            }
            if self.total_peers != 0 {
                my_size += ::protobuf::rt::uint64_size(17, self.total_peers);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.progress != 0. {
                os.write_float(1, self.progress)?;
            }
            if self.upload != 0 {
                os.write_uint64(2, self.upload)?;
            }
            if self.upload_rate != 0 {
                os.write_uint64(3, self.upload_rate)?;
            }
            if self.upload_useful != 0 {
                os.write_uint64(4, self.upload_useful)?;
            }
            if self.upload_useful_rate != 0 {
                os.write_uint64(5, self.upload_useful_rate)?;
            }
            if self.download != 0 {
                os.write_uint64(6, self.download)?;
            }
            if self.download_rate != 0 {
                os.write_uint64(7, self.download_rate)?;
            }
            if self.download_useful != 0 {
                os.write_uint64(8, self.download_useful)?;
            }
            if self.download_useful_rate != 0 {
                os.write_uint64(9, self.download_useful_rate)?;
            }
            if self.total_uploaded != 0 {
                os.write_uint64(10, self.total_uploaded)?;
            }
            if self.total_downloaded != 0 {
                os.write_uint64(11, self.total_downloaded)?;
            }
            if self.total_downloaded_useful != 0 {
                os.write_uint64(12, self.total_downloaded_useful)?;
            }
            if self.wanted_pieces != 0 {
                os.write_uint64(13, self.wanted_pieces)?;
            }
            if self.completed_pieces != 0 {
                os.write_uint64(14, self.completed_pieces)?;
            }
            if self.total_size != 0 {
                os.write_uint64(15, self.total_size)?;
            }
            if self.total_completed_size != 0 {
                os.write_uint64(16, self.total_completed_size)?;
            }
            if self.total_peers != 0 {
                os.write_uint64(17, self.total_peers)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Stats {
            Stats::new()
        }

        fn clear(&mut self) {
            self.progress = 0.;
            self.upload = 0;
            self.upload_rate = 0;
            self.upload_useful = 0;
            self.upload_useful_rate = 0;
            self.download = 0;
            self.download_rate = 0;
            self.download_useful = 0;
            self.download_useful_rate = 0;
            self.total_uploaded = 0;
            self.total_downloaded = 0;
            self.total_downloaded_useful = 0;
            self.wanted_pieces = 0;
            self.completed_pieces = 0;
            self.total_size = 0;
            self.total_completed_size = 0;
            self.total_peers = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Stats {
            static instance: Stats = Stats {
                progress: 0.,
                upload: 0,
                upload_rate: 0,
                upload_useful: 0,
                upload_useful_rate: 0,
                download: 0,
                download_rate: 0,
                download_useful: 0,
                download_useful_rate: 0,
                total_uploaded: 0,
                total_downloaded: 0,
                total_downloaded_useful: 0,
                wanted_pieces: 0,
                completed_pieces: 0,
                total_size: 0,
                total_completed_size: 0,
                total_peers: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:fx.ipc.proto.Torrent.Error)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Error {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Error.type)
        pub type_: ::protobuf::EnumOrUnknown<error::Type>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Error.invalid_url)
        pub invalid_url: ::protobuf::MessageField<error::InvalidUrl>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Error.file_not_found)
        pub file_not_found: ::protobuf::MessageField<error::FileNotFound>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Error.invalid_stream_state)
        pub invalid_stream_state: ::protobuf::MessageField<error::InvalidStreamState>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Error.invalid_handle)
        pub invalid_handle: ::protobuf::MessageField<error::InvalidHandle>,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.Torrent.Error.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Error {
        fn default() -> &'a Error {
            <Error as ::protobuf::Message>::default_instance()
        }
    }

    impl Error {
        pub fn new() -> Error {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for Error {
        const NAME: &'static str = "Error";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = is.read_enum_or_unknown()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.invalid_url)?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.file_not_found)?;
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.invalid_stream_state)?;
                    },
                    42 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.invalid_handle)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.type_ != ::protobuf::EnumOrUnknown::new(error::Type::INVALID_URL) {
                my_size += ::protobuf::rt::int32_size(1, self.type_.value());
            }
            if let Some(v) = self.invalid_url.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.file_not_found.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.invalid_stream_state.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.invalid_handle.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.type_ != ::protobuf::EnumOrUnknown::new(error::Type::INVALID_URL) {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
            }
            if let Some(v) = self.invalid_url.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.file_not_found.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.invalid_stream_state.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            if let Some(v) = self.invalid_handle.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Error {
            Error::new()
        }

        fn clear(&mut self) {
            self.type_ = ::protobuf::EnumOrUnknown::new(error::Type::INVALID_URL);
            self.invalid_url.clear();
            self.file_not_found.clear();
            self.invalid_stream_state.clear();
            self.invalid_handle.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Error {
            static instance: Error = Error {
                type_: ::protobuf::EnumOrUnknown::from_i32(0),
                invalid_url: ::protobuf::MessageField::none(),
                file_not_found: ::protobuf::MessageField::none(),
                invalid_stream_state: ::protobuf::MessageField::none(),
                invalid_handle: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Error`
    pub mod error {
        // @@protoc_insertion_point(message:fx.ipc.proto.Torrent.Error.InvalidUrl)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct InvalidUrl {
            // message fields
            // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Error.InvalidUrl.url)
            pub url: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:fx.ipc.proto.Torrent.Error.InvalidUrl.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a InvalidUrl {
            fn default() -> &'a InvalidUrl {
                <InvalidUrl as ::protobuf::Message>::default_instance()
            }
        }

        impl InvalidUrl {
            pub fn new() -> InvalidUrl {
                ::std::default::Default::default()
            }
        }

        impl ::protobuf::Message for InvalidUrl {
            const NAME: &'static str = "InvalidUrl";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.url = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.url.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.url);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.url.is_empty() {
                    os.write_string(1, &self.url)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> InvalidUrl {
                InvalidUrl::new()
            }

            fn clear(&mut self) {
                self.url.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static InvalidUrl {
                static instance: InvalidUrl = InvalidUrl {
                    url: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:fx.ipc.proto.Torrent.Error.FileNotFound)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct FileNotFound {
            // message fields
            // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Error.FileNotFound.file)
            pub file: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:fx.ipc.proto.Torrent.Error.FileNotFound.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a FileNotFound {
            fn default() -> &'a FileNotFound {
                <FileNotFound as ::protobuf::Message>::default_instance()
            }
        }

        impl FileNotFound {
            pub fn new() -> FileNotFound {
                ::std::default::Default::default()
            }
        }

        impl ::protobuf::Message for FileNotFound {
            const NAME: &'static str = "FileNotFound";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.file = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.file.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.file);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.file.is_empty() {
                    os.write_string(1, &self.file)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> FileNotFound {
                FileNotFound::new()
            }

            fn clear(&mut self) {
                self.file.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static FileNotFound {
                static instance: FileNotFound = FileNotFound {
                    file: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:fx.ipc.proto.Torrent.Error.InvalidStreamState)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct InvalidStreamState {
            // message fields
            // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Error.InvalidStreamState.state)
            pub state: ::protobuf::EnumOrUnknown<super::StreamState>,
            // special fields
            // @@protoc_insertion_point(special_field:fx.ipc.proto.Torrent.Error.InvalidStreamState.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a InvalidStreamState {
            fn default() -> &'a InvalidStreamState {
                <InvalidStreamState as ::protobuf::Message>::default_instance()
            }
        }

        impl InvalidStreamState {
            pub fn new() -> InvalidStreamState {
                ::std::default::Default::default()
            }
        }

        impl ::protobuf::Message for InvalidStreamState {
            const NAME: &'static str = "InvalidStreamState";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.state = is.read_enum_or_unknown()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.state != ::protobuf::EnumOrUnknown::new(super::StreamState::STREAM_PREPARING) {
                    my_size += ::protobuf::rt::int32_size(1, self.state.value());
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.state != ::protobuf::EnumOrUnknown::new(super::StreamState::STREAM_PREPARING) {
                    os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.state))?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> InvalidStreamState {
                InvalidStreamState::new()
            }

            fn clear(&mut self) {
                self.state = ::protobuf::EnumOrUnknown::new(super::StreamState::STREAM_PREPARING);
                self.special_fields.clear();
            }

            fn default_instance() -> &'static InvalidStreamState {
                static instance: InvalidStreamState = InvalidStreamState {
                    state: ::protobuf::EnumOrUnknown::from_i32(0),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:fx.ipc.proto.Torrent.Error.InvalidHandle)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct InvalidHandle {
            // message fields
            // @@protoc_insertion_point(field:fx.ipc.proto.Torrent.Error.InvalidHandle.handle)
            pub handle: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:fx.ipc.proto.Torrent.Error.InvalidHandle.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a InvalidHandle {
            fn default() -> &'a InvalidHandle {
                <InvalidHandle as ::protobuf::Message>::default_instance()
            }
        }

        impl InvalidHandle {
            pub fn new() -> InvalidHandle {
                ::std::default::Default::default()
            }
        }

        impl ::protobuf::Message for InvalidHandle {
            const NAME: &'static str = "InvalidHandle";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.handle = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.handle.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.handle);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.handle.is_empty() {
                    os.write_string(1, &self.handle)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> InvalidHandle {
                InvalidHandle::new()
            }

            fn clear(&mut self) {
                self.handle.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static InvalidHandle {
                static instance: InvalidHandle = InvalidHandle {
                    handle: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:fx.ipc.proto.Torrent.Error.Type)
        pub enum Type {
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Torrent.Error.Type.INVALID_URL)
            INVALID_URL = 0,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Torrent.Error.Type.FILE_NOT_FOUND)
            FILE_NOT_FOUND = 1,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Torrent.Error.Type.INVALID_STREAM_STATE)
            INVALID_STREAM_STATE = 2,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Torrent.Error.Type.INVALID_HANDLE)
            INVALID_HANDLE = 3,
        }

        impl ::protobuf::Enum for Type {
            const NAME: &'static str = "Type";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<Type> {
                match value {
                    0 => ::std::option::Option::Some(Type::INVALID_URL),
                    1 => ::std::option::Option::Some(Type::FILE_NOT_FOUND),
                    2 => ::std::option::Option::Some(Type::INVALID_STREAM_STATE),
                    3 => ::std::option::Option::Some(Type::INVALID_HANDLE),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<Type> {
                match str {
                    "INVALID_URL" => ::std::option::Option::Some(Type::INVALID_URL),
                    "FILE_NOT_FOUND" => ::std::option::Option::Some(Type::FILE_NOT_FOUND),
                    "INVALID_STREAM_STATE" => ::std::option::Option::Some(Type::INVALID_STREAM_STATE),
                    "INVALID_HANDLE" => ::std::option::Option::Some(Type::INVALID_HANDLE),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [Type] = &[
                Type::INVALID_URL,
                Type::FILE_NOT_FOUND,
                Type::INVALID_STREAM_STATE,
                Type::INVALID_HANDLE,
            ];
        }

        impl ::std::default::Default for Type {
            fn default() -> Self {
                Type::INVALID_URL
            }
        }

    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:fx.ipc.proto.Torrent.State)
    pub enum State {
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Torrent.State.INITIALIZING)
        INITIALIZING = 0,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Torrent.State.RETRIEVING_METADATA)
        RETRIEVING_METADATA = 1,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Torrent.State.CHECKING_FILES)
        CHECKING_FILES = 2,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Torrent.State.DOWNLOADING)
        DOWNLOADING = 3,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Torrent.State.FINISHED)
        FINISHED = 4,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Torrent.State.SEEDING)
        SEEDING = 5,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Torrent.State.PAUSED)
        PAUSED = 6,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Torrent.State.ERROR)
        ERROR = 7,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Torrent.State.STOPPED)
        STOPPED = 8,
    }

    impl ::protobuf::Enum for State {
        const NAME: &'static str = "State";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<State> {
            match value {
                0 => ::std::option::Option::Some(State::INITIALIZING),
                1 => ::std::option::Option::Some(State::RETRIEVING_METADATA),
                2 => ::std::option::Option::Some(State::CHECKING_FILES),
                3 => ::std::option::Option::Some(State::DOWNLOADING),
                4 => ::std::option::Option::Some(State::FINISHED),
                5 => ::std::option::Option::Some(State::SEEDING),
                6 => ::std::option::Option::Some(State::PAUSED),
                7 => ::std::option::Option::Some(State::ERROR),
                8 => ::std::option::Option::Some(State::STOPPED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<State> {
            match str {
                "INITIALIZING" => ::std::option::Option::Some(State::INITIALIZING),
                "RETRIEVING_METADATA" => ::std::option::Option::Some(State::RETRIEVING_METADATA),
                "CHECKING_FILES" => ::std::option::Option::Some(State::CHECKING_FILES),
                "DOWNLOADING" => ::std::option::Option::Some(State::DOWNLOADING),
                "FINISHED" => ::std::option::Option::Some(State::FINISHED),
                "SEEDING" => ::std::option::Option::Some(State::SEEDING),
                "PAUSED" => ::std::option::Option::Some(State::PAUSED),
                "ERROR" => ::std::option::Option::Some(State::ERROR),
                "STOPPED" => ::std::option::Option::Some(State::STOPPED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [State] = &[
            State::INITIALIZING,
            State::RETRIEVING_METADATA,
            State::CHECKING_FILES,
            State::DOWNLOADING,
            State::FINISHED,
            State::SEEDING,
            State::PAUSED,
            State::ERROR,
            State::STOPPED,
        ];
    }

    impl ::std::default::Default for State {
        fn default() -> Self {
            State::INITIALIZING
        }
    }


    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:fx.ipc.proto.Torrent.StreamState)
    pub enum StreamState {
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Torrent.StreamState.STREAM_PREPARING)
        STREAM_PREPARING = 0,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Torrent.StreamState.STREAMING)
        STREAMING = 1,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Torrent.StreamState.STREAM_STOPPED)
        STREAM_STOPPED = 2,
    }

    impl ::protobuf::Enum for StreamState {
        const NAME: &'static str = "StreamState";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<StreamState> {
            match value {
                0 => ::std::option::Option::Some(StreamState::STREAM_PREPARING),
                1 => ::std::option::Option::Some(StreamState::STREAMING),
                2 => ::std::option::Option::Some(StreamState::STREAM_STOPPED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<StreamState> {
            match str {
                "STREAM_PREPARING" => ::std::option::Option::Some(StreamState::STREAM_PREPARING),
                "STREAMING" => ::std::option::Option::Some(StreamState::STREAMING),
                "STREAM_STOPPED" => ::std::option::Option::Some(StreamState::STREAM_STOPPED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [StreamState] = &[
            StreamState::STREAM_PREPARING,
            StreamState::STREAMING,
            StreamState::STREAM_STOPPED,
        ];
    }

    impl ::std::default::Default for StreamState {
        fn default() -> Self {
            StreamState::STREAM_PREPARING
        }
    }

}

// @@protoc_insertion_point(message:fx.ipc.proto.Peer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Peer {
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.Peer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Peer {
    fn default() -> &'a Peer {
        <Peer as ::protobuf::Message>::default_instance()
    }
}

impl Peer {
    pub fn new() -> Peer {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Peer {
    const NAME: &'static str = "Peer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Peer {
        Peer::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Peer {
        static instance: Peer = Peer {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `Peer`
pub mod peer {
    // @@protoc_insertion_point(message:fx.ipc.proto.Peer.Info)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Info {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.Peer.Info.handle)
        pub handle: ::protobuf::MessageField<super::super::message::Handle>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Peer.Info.id)
        pub id: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Peer.Info.address)
        pub address: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Peer.Info.connection_type)
        pub connection_type: ::protobuf::EnumOrUnknown<ConnectionDirection>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Peer.Info.connection_protocol)
        pub connection_protocol: ::protobuf::EnumOrUnknown<ConnectionProtocol>,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.Peer.Info.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Info {
        fn default() -> &'a Info {
            <Info as ::protobuf::Message>::default_instance()
        }
    }

    impl Info {
        pub fn new() -> Info {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for Info {
        const NAME: &'static str = "Info";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.handle)?;
                    },
                    18 => {
                        self.id = is.read_string()?;
                    },
                    26 => {
                        self.address = is.read_string()?;
                    },
                    32 => {
                        self.connection_type = is.read_enum_or_unknown()?;
                    },
                    40 => {
                        self.connection_protocol = is.read_enum_or_unknown()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.handle.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if !self.id.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.id);
            }
            if !self.address.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.address);
            }
            if self.connection_type != ::protobuf::EnumOrUnknown::new(ConnectionDirection::INBOUND) {
                my_size += ::protobuf::rt::int32_size(4, self.connection_type.value());
            }
            if self.connection_protocol != ::protobuf::EnumOrUnknown::new(ConnectionProtocol::TCP) {
                my_size += ::protobuf::rt::int32_size(5, self.connection_protocol.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.handle.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if !self.id.is_empty() {
                os.write_string(2, &self.id)?;
            }
            if !self.address.is_empty() {
                os.write_string(3, &self.address)?;
            }
            if self.connection_type != ::protobuf::EnumOrUnknown::new(ConnectionDirection::INBOUND) {
                os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.connection_type))?;
            }
            if self.connection_protocol != ::protobuf::EnumOrUnknown::new(ConnectionProtocol::TCP) {
                os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.connection_protocol))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Info {
            Info::new()
        }

        fn clear(&mut self) {
            self.handle.clear();
            self.id.clear();
            self.address.clear();
            self.connection_type = ::protobuf::EnumOrUnknown::new(ConnectionDirection::INBOUND);
            self.connection_protocol = ::protobuf::EnumOrUnknown::new(ConnectionProtocol::TCP);
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Info {
            static instance: Info = Info {
                handle: ::protobuf::MessageField::none(),
                id: ::std::string::String::new(),
                address: ::std::string::String::new(),
                connection_type: ::protobuf::EnumOrUnknown::from_i32(0),
                connection_protocol: ::protobuf::EnumOrUnknown::from_i32(0),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:fx.ipc.proto.Peer.ConnectionDirection)
    pub enum ConnectionDirection {
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Peer.ConnectionDirection.INBOUND)
        INBOUND = 0,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Peer.ConnectionDirection.OUTBOUND)
        OUTBOUND = 1,
    }

    impl ::protobuf::Enum for ConnectionDirection {
        const NAME: &'static str = "ConnectionDirection";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ConnectionDirection> {
            match value {
                0 => ::std::option::Option::Some(ConnectionDirection::INBOUND),
                1 => ::std::option::Option::Some(ConnectionDirection::OUTBOUND),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ConnectionDirection> {
            match str {
                "INBOUND" => ::std::option::Option::Some(ConnectionDirection::INBOUND),
                "OUTBOUND" => ::std::option::Option::Some(ConnectionDirection::OUTBOUND),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ConnectionDirection] = &[
            ConnectionDirection::INBOUND,
            ConnectionDirection::OUTBOUND,
        ];
    }

    impl ::std::default::Default for ConnectionDirection {
        fn default() -> Self {
            ConnectionDirection::INBOUND
        }
    }


    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:fx.ipc.proto.Peer.ConnectionProtocol)
    pub enum ConnectionProtocol {
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Peer.ConnectionProtocol.TCP)
        TCP = 0,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Peer.ConnectionProtocol.UTP)
        UTP = 1,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Peer.ConnectionProtocol.HTTP)
        HTTP = 2,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Peer.ConnectionProtocol.OTHER)
        OTHER = 3,
    }

    impl ::protobuf::Enum for ConnectionProtocol {
        const NAME: &'static str = "ConnectionProtocol";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ConnectionProtocol> {
            match value {
                0 => ::std::option::Option::Some(ConnectionProtocol::TCP),
                1 => ::std::option::Option::Some(ConnectionProtocol::UTP),
                2 => ::std::option::Option::Some(ConnectionProtocol::HTTP),
                3 => ::std::option::Option::Some(ConnectionProtocol::OTHER),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ConnectionProtocol> {
            match str {
                "TCP" => ::std::option::Option::Some(ConnectionProtocol::TCP),
                "UTP" => ::std::option::Option::Some(ConnectionProtocol::UTP),
                "HTTP" => ::std::option::Option::Some(ConnectionProtocol::HTTP),
                "OTHER" => ::std::option::Option::Some(ConnectionProtocol::OTHER),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ConnectionProtocol] = &[
            ConnectionProtocol::TCP,
            ConnectionProtocol::UTP,
            ConnectionProtocol::HTTP,
            ConnectionProtocol::OTHER,
        ];
    }

    impl ::std::default::Default for ConnectionProtocol {
        fn default() -> Self {
            ConnectionProtocol::TCP
        }
    }

}

// @@protoc_insertion_point(message:fx.ipc.proto.MagnetInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MagnetInfo {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.MagnetInfo.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:fx.ipc.proto.MagnetInfo.magnet_uri)
    pub magnet_uri: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.MagnetInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MagnetInfo {
    fn default() -> &'a MagnetInfo {
        <MagnetInfo as ::protobuf::Message>::default_instance()
    }
}

impl MagnetInfo {
    pub fn new() -> MagnetInfo {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MagnetInfo {
    const NAME: &'static str = "MagnetInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.magnet_uri = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.magnet_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.magnet_uri);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.magnet_uri.is_empty() {
            os.write_string(2, &self.magnet_uri)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MagnetInfo {
        MagnetInfo::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.magnet_uri.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MagnetInfo {
        static instance: MagnetInfo = MagnetInfo {
            name: ::std::string::String::new(),
            magnet_uri: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.TorrentHealthRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TorrentHealthRequest {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.TorrentHealthRequest.uri)
    pub uri: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.TorrentHealthRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TorrentHealthRequest {
    fn default() -> &'a TorrentHealthRequest {
        <TorrentHealthRequest as ::protobuf::Message>::default_instance()
    }
}

impl TorrentHealthRequest {
    pub fn new() -> TorrentHealthRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TorrentHealthRequest {
    const NAME: &'static str = "TorrentHealthRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.uri = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.uri.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uri);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.uri.is_empty() {
            os.write_string(1, &self.uri)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TorrentHealthRequest {
        TorrentHealthRequest::new()
    }

    fn clear(&mut self) {
        self.uri.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TorrentHealthRequest {
        static instance: TorrentHealthRequest = TorrentHealthRequest {
            uri: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.TorrentHealthResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TorrentHealthResponse {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.TorrentHealthResponse.result)
    pub result: ::protobuf::EnumOrUnknown<super::message::response::Result>,
    // @@protoc_insertion_point(field:fx.ipc.proto.TorrentHealthResponse.health)
    pub health: ::protobuf::MessageField<torrent::Health>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.TorrentHealthResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TorrentHealthResponse {
    fn default() -> &'a TorrentHealthResponse {
        <TorrentHealthResponse as ::protobuf::Message>::default_instance()
    }
}

impl TorrentHealthResponse {
    pub fn new() -> TorrentHealthResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TorrentHealthResponse {
    const NAME: &'static str = "TorrentHealthResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.health)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.result != ::protobuf::EnumOrUnknown::new(super::message::response::Result::OK) {
            my_size += ::protobuf::rt::int32_size(1, self.result.value());
        }
        if let Some(v) = self.health.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.result != ::protobuf::EnumOrUnknown::new(super::message::response::Result::OK) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.result))?;
        }
        if let Some(v) = self.health.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TorrentHealthResponse {
        TorrentHealthResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::protobuf::EnumOrUnknown::new(super::message::response::Result::OK);
        self.health.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TorrentHealthResponse {
        static instance: TorrentHealthResponse = TorrentHealthResponse {
            result: ::protobuf::EnumOrUnknown::from_i32(0),
            health: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.CalculateTorrentHealthRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CalculateTorrentHealthRequest {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.CalculateTorrentHealthRequest.seeds)
    pub seeds: u32,
    // @@protoc_insertion_point(field:fx.ipc.proto.CalculateTorrentHealthRequest.leechers)
    pub leechers: u32,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.CalculateTorrentHealthRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CalculateTorrentHealthRequest {
    fn default() -> &'a CalculateTorrentHealthRequest {
        <CalculateTorrentHealthRequest as ::protobuf::Message>::default_instance()
    }
}

impl CalculateTorrentHealthRequest {
    pub fn new() -> CalculateTorrentHealthRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CalculateTorrentHealthRequest {
    const NAME: &'static str = "CalculateTorrentHealthRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.seeds = is.read_uint32()?;
                },
                16 => {
                    self.leechers = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.seeds != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.seeds);
        }
        if self.leechers != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.leechers);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.seeds != 0 {
            os.write_uint32(1, self.seeds)?;
        }
        if self.leechers != 0 {
            os.write_uint32(2, self.leechers)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CalculateTorrentHealthRequest {
        CalculateTorrentHealthRequest::new()
    }

    fn clear(&mut self) {
        self.seeds = 0;
        self.leechers = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CalculateTorrentHealthRequest {
        static instance: CalculateTorrentHealthRequest = CalculateTorrentHealthRequest {
            seeds: 0,
            leechers: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.CalculateTorrentHealthResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CalculateTorrentHealthResponse {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.CalculateTorrentHealthResponse.health)
    pub health: ::protobuf::MessageField<torrent::Health>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.CalculateTorrentHealthResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CalculateTorrentHealthResponse {
    fn default() -> &'a CalculateTorrentHealthResponse {
        <CalculateTorrentHealthResponse as ::protobuf::Message>::default_instance()
    }
}

impl CalculateTorrentHealthResponse {
    pub fn new() -> CalculateTorrentHealthResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CalculateTorrentHealthResponse {
    const NAME: &'static str = "CalculateTorrentHealthResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.health)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.health.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.health.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CalculateTorrentHealthResponse {
        CalculateTorrentHealthResponse::new()
    }

    fn clear(&mut self) {
        self.health.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CalculateTorrentHealthResponse {
        static instance: CalculateTorrentHealthResponse = CalculateTorrentHealthResponse {
            health: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.IsMagnetUriStoredRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IsMagnetUriStoredRequest {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.IsMagnetUriStoredRequest.magnet_uri)
    pub magnet_uri: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.IsMagnetUriStoredRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IsMagnetUriStoredRequest {
    fn default() -> &'a IsMagnetUriStoredRequest {
        <IsMagnetUriStoredRequest as ::protobuf::Message>::default_instance()
    }
}

impl IsMagnetUriStoredRequest {
    pub fn new() -> IsMagnetUriStoredRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for IsMagnetUriStoredRequest {
    const NAME: &'static str = "IsMagnetUriStoredRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.magnet_uri = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.magnet_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.magnet_uri);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.magnet_uri.is_empty() {
            os.write_string(1, &self.magnet_uri)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IsMagnetUriStoredRequest {
        IsMagnetUriStoredRequest::new()
    }

    fn clear(&mut self) {
        self.magnet_uri.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IsMagnetUriStoredRequest {
        static instance: IsMagnetUriStoredRequest = IsMagnetUriStoredRequest {
            magnet_uri: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.IsMagnetUriStoredResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IsMagnetUriStoredResponse {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.IsMagnetUriStoredResponse.is_stored)
    pub is_stored: bool,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.IsMagnetUriStoredResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IsMagnetUriStoredResponse {
    fn default() -> &'a IsMagnetUriStoredResponse {
        <IsMagnetUriStoredResponse as ::protobuf::Message>::default_instance()
    }
}

impl IsMagnetUriStoredResponse {
    pub fn new() -> IsMagnetUriStoredResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for IsMagnetUriStoredResponse {
    const NAME: &'static str = "IsMagnetUriStoredResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_stored = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.is_stored != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.is_stored != false {
            os.write_bool(1, self.is_stored)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IsMagnetUriStoredResponse {
        IsMagnetUriStoredResponse::new()
    }

    fn clear(&mut self) {
        self.is_stored = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IsMagnetUriStoredResponse {
        static instance: IsMagnetUriStoredResponse = IsMagnetUriStoredResponse {
            is_stored: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.GetTorrentCollectionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetTorrentCollectionRequest {
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.GetTorrentCollectionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetTorrentCollectionRequest {
    fn default() -> &'a GetTorrentCollectionRequest {
        <GetTorrentCollectionRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTorrentCollectionRequest {
    pub fn new() -> GetTorrentCollectionRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetTorrentCollectionRequest {
    const NAME: &'static str = "GetTorrentCollectionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetTorrentCollectionRequest {
        GetTorrentCollectionRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetTorrentCollectionRequest {
        static instance: GetTorrentCollectionRequest = GetTorrentCollectionRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.GetTorrentCollectionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetTorrentCollectionResponse {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.GetTorrentCollectionResponse.result)
    pub result: ::protobuf::EnumOrUnknown<super::message::response::Result>,
    // @@protoc_insertion_point(field:fx.ipc.proto.GetTorrentCollectionResponse.torrents)
    pub torrents: ::std::vec::Vec<MagnetInfo>,
    // @@protoc_insertion_point(field:fx.ipc.proto.GetTorrentCollectionResponse.error)
    pub error: ::protobuf::MessageField<torrent::Error>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.GetTorrentCollectionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetTorrentCollectionResponse {
    fn default() -> &'a GetTorrentCollectionResponse {
        <GetTorrentCollectionResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetTorrentCollectionResponse {
    pub fn new() -> GetTorrentCollectionResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetTorrentCollectionResponse {
    const NAME: &'static str = "GetTorrentCollectionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.torrents.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.result != ::protobuf::EnumOrUnknown::new(super::message::response::Result::OK) {
            my_size += ::protobuf::rt::int32_size(1, self.result.value());
        }
        for value in &self.torrents {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.result != ::protobuf::EnumOrUnknown::new(super::message::response::Result::OK) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.result))?;
        }
        for v in &self.torrents {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetTorrentCollectionResponse {
        GetTorrentCollectionResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::protobuf::EnumOrUnknown::new(super::message::response::Result::OK);
        self.torrents.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetTorrentCollectionResponse {
        static instance: GetTorrentCollectionResponse = GetTorrentCollectionResponse {
            result: ::protobuf::EnumOrUnknown::from_i32(0),
            torrents: ::std::vec::Vec::new(),
            error: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.AddTorrentCollectionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AddTorrentCollectionRequest {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.AddTorrentCollectionRequest.type)
    pub type_: ::std::string::String,
    // @@protoc_insertion_point(field:fx.ipc.proto.AddTorrentCollectionRequest.magnet_info)
    pub magnet_info: ::protobuf::MessageField<MagnetInfo>,
    // @@protoc_insertion_point(field:fx.ipc.proto.AddTorrentCollectionRequest.torrent_info)
    pub torrent_info: ::protobuf::MessageField<torrent::Info>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.AddTorrentCollectionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddTorrentCollectionRequest {
    fn default() -> &'a AddTorrentCollectionRequest {
        <AddTorrentCollectionRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddTorrentCollectionRequest {
    pub fn new() -> AddTorrentCollectionRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AddTorrentCollectionRequest {
    const NAME: &'static str = "AddTorrentCollectionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.magnet_info)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.torrent_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.type_);
        }
        if let Some(v) = self.magnet_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.torrent_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.type_.is_empty() {
            os.write_string(1, &self.type_)?;
        }
        if let Some(v) = self.magnet_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.torrent_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddTorrentCollectionRequest {
        AddTorrentCollectionRequest::new()
    }

    fn clear(&mut self) {
        self.type_.clear();
        self.magnet_info.clear();
        self.torrent_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddTorrentCollectionRequest {
        static instance: AddTorrentCollectionRequest = AddTorrentCollectionRequest {
            type_: ::std::string::String::new(),
            magnet_info: ::protobuf::MessageField::none(),
            torrent_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.AddTorrentCollectionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AddTorrentCollectionResponse {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.AddTorrentCollectionResponse.result)
    pub result: ::protobuf::EnumOrUnknown<super::message::response::Result>,
    // @@protoc_insertion_point(field:fx.ipc.proto.AddTorrentCollectionResponse.error)
    pub error: ::protobuf::MessageField<torrent::Error>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.AddTorrentCollectionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddTorrentCollectionResponse {
    fn default() -> &'a AddTorrentCollectionResponse {
        <AddTorrentCollectionResponse as ::protobuf::Message>::default_instance()
    }
}

impl AddTorrentCollectionResponse {
    pub fn new() -> AddTorrentCollectionResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AddTorrentCollectionResponse {
    const NAME: &'static str = "AddTorrentCollectionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.result != ::protobuf::EnumOrUnknown::new(super::message::response::Result::OK) {
            my_size += ::protobuf::rt::int32_size(1, self.result.value());
        }
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.result != ::protobuf::EnumOrUnknown::new(super::message::response::Result::OK) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.result))?;
        }
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddTorrentCollectionResponse {
        AddTorrentCollectionResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::protobuf::EnumOrUnknown::new(super::message::response::Result::OK);
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddTorrentCollectionResponse {
        static instance: AddTorrentCollectionResponse = AddTorrentCollectionResponse {
            result: ::protobuf::EnumOrUnknown::from_i32(0),
            error: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.RemoveTorrentCollectionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RemoveTorrentCollectionRequest {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.RemoveTorrentCollectionRequest.type)
    pub type_: ::std::string::String,
    // @@protoc_insertion_point(field:fx.ipc.proto.RemoveTorrentCollectionRequest.magnet_info)
    pub magnet_info: ::protobuf::MessageField<MagnetInfo>,
    // @@protoc_insertion_point(field:fx.ipc.proto.RemoveTorrentCollectionRequest.torrent_info)
    pub torrent_info: ::protobuf::MessageField<torrent::Info>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.RemoveTorrentCollectionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RemoveTorrentCollectionRequest {
    fn default() -> &'a RemoveTorrentCollectionRequest {
        <RemoveTorrentCollectionRequest as ::protobuf::Message>::default_instance()
    }
}

impl RemoveTorrentCollectionRequest {
    pub fn new() -> RemoveTorrentCollectionRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RemoveTorrentCollectionRequest {
    const NAME: &'static str = "RemoveTorrentCollectionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.magnet_info)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.torrent_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.type_);
        }
        if let Some(v) = self.magnet_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.torrent_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.type_.is_empty() {
            os.write_string(1, &self.type_)?;
        }
        if let Some(v) = self.magnet_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.torrent_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RemoveTorrentCollectionRequest {
        RemoveTorrentCollectionRequest::new()
    }

    fn clear(&mut self) {
        self.type_.clear();
        self.magnet_info.clear();
        self.torrent_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RemoveTorrentCollectionRequest {
        static instance: RemoveTorrentCollectionRequest = RemoveTorrentCollectionRequest {
            type_: ::std::string::String::new(),
            magnet_info: ::protobuf::MessageField::none(),
            torrent_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.CleanTorrentsDirectoryRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CleanTorrentsDirectoryRequest {
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.CleanTorrentsDirectoryRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CleanTorrentsDirectoryRequest {
    fn default() -> &'a CleanTorrentsDirectoryRequest {
        <CleanTorrentsDirectoryRequest as ::protobuf::Message>::default_instance()
    }
}

impl CleanTorrentsDirectoryRequest {
    pub fn new() -> CleanTorrentsDirectoryRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CleanTorrentsDirectoryRequest {
    const NAME: &'static str = "CleanTorrentsDirectoryRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CleanTorrentsDirectoryRequest {
        CleanTorrentsDirectoryRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CleanTorrentsDirectoryRequest {
        static instance: CleanTorrentsDirectoryRequest = CleanTorrentsDirectoryRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.TorrentEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TorrentEvent {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.TorrentEvent.torrent_handle)
    pub torrent_handle: ::protobuf::MessageField<super::message::Handle>,
    // @@protoc_insertion_point(field:fx.ipc.proto.TorrentEvent.event)
    pub event: ::protobuf::EnumOrUnknown<torrent_event::Event>,
    // @@protoc_insertion_point(field:fx.ipc.proto.TorrentEvent.state_changed)
    pub state_changed: ::protobuf::MessageField<torrent_event::StateChanged>,
    // @@protoc_insertion_point(field:fx.ipc.proto.TorrentEvent.peer_connected)
    pub peer_connected: ::protobuf::MessageField<torrent_event::PeerConnected>,
    // @@protoc_insertion_point(field:fx.ipc.proto.TorrentEvent.peer_disconnected)
    pub peer_disconnected: ::protobuf::MessageField<torrent_event::PeerDisconnected>,
    // @@protoc_insertion_point(field:fx.ipc.proto.TorrentEvent.piece_completed)
    pub piece_completed: ::protobuf::MessageField<torrent_event::PieceCompleted>,
    // @@protoc_insertion_point(field:fx.ipc.proto.TorrentEvent.stats)
    pub stats: ::protobuf::MessageField<torrent_event::Stats>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.TorrentEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TorrentEvent {
    fn default() -> &'a TorrentEvent {
        <TorrentEvent as ::protobuf::Message>::default_instance()
    }
}

impl TorrentEvent {
    pub fn new() -> TorrentEvent {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TorrentEvent {
    const NAME: &'static str = "TorrentEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.torrent_handle)?;
                },
                16 => {
                    self.event = is.read_enum_or_unknown()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.state_changed)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.peer_connected)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.peer_disconnected)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.piece_completed)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stats)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.torrent_handle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.event != ::protobuf::EnumOrUnknown::new(torrent_event::Event::STATE_CHANGED) {
            my_size += ::protobuf::rt::int32_size(2, self.event.value());
        }
        if let Some(v) = self.state_changed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.peer_connected.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.peer_disconnected.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.piece_completed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.torrent_handle.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.event != ::protobuf::EnumOrUnknown::new(torrent_event::Event::STATE_CHANGED) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.event))?;
        }
        if let Some(v) = self.state_changed.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.peer_connected.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.peer_disconnected.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.piece_completed.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.stats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TorrentEvent {
        TorrentEvent::new()
    }

    fn clear(&mut self) {
        self.torrent_handle.clear();
        self.event = ::protobuf::EnumOrUnknown::new(torrent_event::Event::STATE_CHANGED);
        self.state_changed.clear();
        self.peer_connected.clear();
        self.peer_disconnected.clear();
        self.piece_completed.clear();
        self.stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TorrentEvent {
        static instance: TorrentEvent = TorrentEvent {
            torrent_handle: ::protobuf::MessageField::none(),
            event: ::protobuf::EnumOrUnknown::from_i32(0),
            state_changed: ::protobuf::MessageField::none(),
            peer_connected: ::protobuf::MessageField::none(),
            peer_disconnected: ::protobuf::MessageField::none(),
            piece_completed: ::protobuf::MessageField::none(),
            stats: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `TorrentEvent`
pub mod torrent_event {
    // @@protoc_insertion_point(message:fx.ipc.proto.TorrentEvent.StateChanged)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StateChanged {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.TorrentEvent.StateChanged.state)
        pub state: ::protobuf::EnumOrUnknown<super::torrent::State>,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.TorrentEvent.StateChanged.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StateChanged {
        fn default() -> &'a StateChanged {
            <StateChanged as ::protobuf::Message>::default_instance()
        }
    }

    impl StateChanged {
        pub fn new() -> StateChanged {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for StateChanged {
        const NAME: &'static str = "StateChanged";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.state = is.read_enum_or_unknown()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.state != ::protobuf::EnumOrUnknown::new(super::torrent::State::INITIALIZING) {
                my_size += ::protobuf::rt::int32_size(1, self.state.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.state != ::protobuf::EnumOrUnknown::new(super::torrent::State::INITIALIZING) {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.state))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StateChanged {
            StateChanged::new()
        }

        fn clear(&mut self) {
            self.state = ::protobuf::EnumOrUnknown::new(super::torrent::State::INITIALIZING);
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StateChanged {
            static instance: StateChanged = StateChanged {
                state: ::protobuf::EnumOrUnknown::from_i32(0),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:fx.ipc.proto.TorrentEvent.PeerConnected)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PeerConnected {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.TorrentEvent.PeerConnected.peer_info)
        pub peer_info: ::protobuf::MessageField<super::peer::Info>,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.TorrentEvent.PeerConnected.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PeerConnected {
        fn default() -> &'a PeerConnected {
            <PeerConnected as ::protobuf::Message>::default_instance()
        }
    }

    impl PeerConnected {
        pub fn new() -> PeerConnected {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for PeerConnected {
        const NAME: &'static str = "PeerConnected";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.peer_info)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.peer_info.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.peer_info.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PeerConnected {
            PeerConnected::new()
        }

        fn clear(&mut self) {
            self.peer_info.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PeerConnected {
            static instance: PeerConnected = PeerConnected {
                peer_info: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:fx.ipc.proto.TorrentEvent.PeerDisconnected)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PeerDisconnected {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.TorrentEvent.PeerDisconnected.peer_info)
        pub peer_info: ::protobuf::MessageField<super::peer::Info>,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.TorrentEvent.PeerDisconnected.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PeerDisconnected {
        fn default() -> &'a PeerDisconnected {
            <PeerDisconnected as ::protobuf::Message>::default_instance()
        }
    }

    impl PeerDisconnected {
        pub fn new() -> PeerDisconnected {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for PeerDisconnected {
        const NAME: &'static str = "PeerDisconnected";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.peer_info)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.peer_info.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.peer_info.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PeerDisconnected {
            PeerDisconnected::new()
        }

        fn clear(&mut self) {
            self.peer_info.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PeerDisconnected {
            static instance: PeerDisconnected = PeerDisconnected {
                peer_info: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:fx.ipc.proto.TorrentEvent.PieceCompleted)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PieceCompleted {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.TorrentEvent.PieceCompleted.piece_index)
        pub piece_index: u64,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.TorrentEvent.PieceCompleted.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PieceCompleted {
        fn default() -> &'a PieceCompleted {
            <PieceCompleted as ::protobuf::Message>::default_instance()
        }
    }

    impl PieceCompleted {
        pub fn new() -> PieceCompleted {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for PieceCompleted {
        const NAME: &'static str = "PieceCompleted";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.piece_index = is.read_uint64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.piece_index != 0 {
                my_size += ::protobuf::rt::uint64_size(1, self.piece_index);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.piece_index != 0 {
                os.write_uint64(1, self.piece_index)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PieceCompleted {
            PieceCompleted::new()
        }

        fn clear(&mut self) {
            self.piece_index = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PieceCompleted {
            static instance: PieceCompleted = PieceCompleted {
                piece_index: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:fx.ipc.proto.TorrentEvent.Stats)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Stats {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.TorrentEvent.Stats.stats)
        pub stats: ::protobuf::MessageField<super::torrent::Stats>,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.TorrentEvent.Stats.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Stats {
        fn default() -> &'a Stats {
            <Stats as ::protobuf::Message>::default_instance()
        }
    }

    impl Stats {
        pub fn new() -> Stats {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for Stats {
        const NAME: &'static str = "Stats";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.stats)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.stats.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.stats.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Stats {
            Stats::new()
        }

        fn clear(&mut self) {
            self.stats.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Stats {
            static instance: Stats = Stats {
                stats: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:fx.ipc.proto.TorrentEvent.Event)
    pub enum Event {
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.TorrentEvent.Event.STATE_CHANGED)
        STATE_CHANGED = 0,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.TorrentEvent.Event.METADATA_CHANGED)
        METADATA_CHANGED = 1,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.TorrentEvent.Event.PEER_CONNECTED)
        PEER_CONNECTED = 2,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.TorrentEvent.Event.PEER_DISCONNECTED)
        PEER_DISCONNECTED = 3,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.TorrentEvent.Event.TRACKERS_CHANGED)
        TRACKERS_CHANGED = 4,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.TorrentEvent.Event.PIECES_CHANGED)
        PIECES_CHANGED = 6,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.TorrentEvent.Event.PIECE_PRIORITIES_CHANGED)
        PIECE_PRIORITIES_CHANGED = 7,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.TorrentEvent.Event.PIECE_COMPLETED)
        PIECE_COMPLETED = 8,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.TorrentEvent.Event.FILES_CHANGED)
        FILES_CHANGED = 9,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.TorrentEvent.Event.OPTIONS_CHANGED)
        OPTIONS_CHANGED = 10,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.TorrentEvent.Event.STATS)
        STATS = 11,
    }

    impl ::protobuf::Enum for Event {
        const NAME: &'static str = "Event";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Event> {
            match value {
                0 => ::std::option::Option::Some(Event::STATE_CHANGED),
                1 => ::std::option::Option::Some(Event::METADATA_CHANGED),
                2 => ::std::option::Option::Some(Event::PEER_CONNECTED),
                3 => ::std::option::Option::Some(Event::PEER_DISCONNECTED),
                4 => ::std::option::Option::Some(Event::TRACKERS_CHANGED),
                6 => ::std::option::Option::Some(Event::PIECES_CHANGED),
                7 => ::std::option::Option::Some(Event::PIECE_PRIORITIES_CHANGED),
                8 => ::std::option::Option::Some(Event::PIECE_COMPLETED),
                9 => ::std::option::Option::Some(Event::FILES_CHANGED),
                10 => ::std::option::Option::Some(Event::OPTIONS_CHANGED),
                11 => ::std::option::Option::Some(Event::STATS),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Event> {
            match str {
                "STATE_CHANGED" => ::std::option::Option::Some(Event::STATE_CHANGED),
                "METADATA_CHANGED" => ::std::option::Option::Some(Event::METADATA_CHANGED),
                "PEER_CONNECTED" => ::std::option::Option::Some(Event::PEER_CONNECTED),
                "PEER_DISCONNECTED" => ::std::option::Option::Some(Event::PEER_DISCONNECTED),
                "TRACKERS_CHANGED" => ::std::option::Option::Some(Event::TRACKERS_CHANGED),
                "PIECES_CHANGED" => ::std::option::Option::Some(Event::PIECES_CHANGED),
                "PIECE_PRIORITIES_CHANGED" => ::std::option::Option::Some(Event::PIECE_PRIORITIES_CHANGED),
                "PIECE_COMPLETED" => ::std::option::Option::Some(Event::PIECE_COMPLETED),
                "FILES_CHANGED" => ::std::option::Option::Some(Event::FILES_CHANGED),
                "OPTIONS_CHANGED" => ::std::option::Option::Some(Event::OPTIONS_CHANGED),
                "STATS" => ::std::option::Option::Some(Event::STATS),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Event] = &[
            Event::STATE_CHANGED,
            Event::METADATA_CHANGED,
            Event::PEER_CONNECTED,
            Event::PEER_DISCONNECTED,
            Event::TRACKERS_CHANGED,
            Event::PIECES_CHANGED,
            Event::PIECE_PRIORITIES_CHANGED,
            Event::PIECE_COMPLETED,
            Event::FILES_CHANGED,
            Event::OPTIONS_CHANGED,
            Event::STATS,
        ];
    }

    impl ::std::default::Default for Event {
        fn default() -> Self {
            Event::STATE_CHANGED
        }
    }

}
