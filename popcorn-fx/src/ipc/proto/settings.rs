// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by protoc 29.3
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `settings.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

// @@protoc_insertion_point(message:fx.ipc.proto.ApplicationSettingsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ApplicationSettingsRequest {
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.ApplicationSettingsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ApplicationSettingsRequest {
    fn default() -> &'a ApplicationSettingsRequest {
        <ApplicationSettingsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ApplicationSettingsRequest {
    pub fn new() -> ApplicationSettingsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ApplicationSettingsRequest {
    const NAME: &'static str = "ApplicationSettingsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ApplicationSettingsRequest {
        ApplicationSettingsRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ApplicationSettingsRequest {
        static instance: ApplicationSettingsRequest = ApplicationSettingsRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.ApplicationSettingsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ApplicationSettingsResponse {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettingsResponse.settings)
    pub settings: ::protobuf::MessageField<ApplicationSettings>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.ApplicationSettingsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ApplicationSettingsResponse {
    fn default() -> &'a ApplicationSettingsResponse {
        <ApplicationSettingsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ApplicationSettingsResponse {
    pub fn new() -> ApplicationSettingsResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ApplicationSettingsResponse {
    const NAME: &'static str = "ApplicationSettingsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.settings)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ApplicationSettingsResponse {
        ApplicationSettingsResponse::new()
    }

    fn clear(&mut self) {
        self.settings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ApplicationSettingsResponse {
        static instance: ApplicationSettingsResponse = ApplicationSettingsResponse {
            settings: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.ApplicationSettings)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ApplicationSettings {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettings.subtitle_settings)
    pub subtitle_settings: ::protobuf::MessageField<application_settings::SubtitleSettings>,
    // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettings.ui_settings)
    pub ui_settings: ::protobuf::MessageField<application_settings::UISettings>,
    // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettings.server_settings)
    pub server_settings: ::protobuf::MessageField<application_settings::ServerSettings>,
    // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettings.torrent_settings)
    pub torrent_settings: ::protobuf::MessageField<application_settings::TorrentSettings>,
    // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettings.playback_settings)
    pub playback_settings: ::protobuf::MessageField<application_settings::PlaybackSettings>,
    // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettings.tracking_settings)
    pub tracking_settings: ::protobuf::MessageField<application_settings::TrackingSettings>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.ApplicationSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ApplicationSettings {
    fn default() -> &'a ApplicationSettings {
        <ApplicationSettings as ::protobuf::Message>::default_instance()
    }
}

impl ApplicationSettings {
    pub fn new() -> ApplicationSettings {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ApplicationSettings {
    const NAME: &'static str = "ApplicationSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.subtitle_settings)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ui_settings)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.server_settings)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.torrent_settings)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.playback_settings)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tracking_settings)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.subtitle_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ui_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.server_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.torrent_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.playback_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tracking_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.subtitle_settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.ui_settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.server_settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.torrent_settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.playback_settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.tracking_settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ApplicationSettings {
        ApplicationSettings::new()
    }

    fn clear(&mut self) {
        self.subtitle_settings.clear();
        self.ui_settings.clear();
        self.server_settings.clear();
        self.torrent_settings.clear();
        self.playback_settings.clear();
        self.tracking_settings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ApplicationSettings {
        static instance: ApplicationSettings = ApplicationSettings {
            subtitle_settings: ::protobuf::MessageField::none(),
            ui_settings: ::protobuf::MessageField::none(),
            server_settings: ::protobuf::MessageField::none(),
            torrent_settings: ::protobuf::MessageField::none(),
            playback_settings: ::protobuf::MessageField::none(),
            tracking_settings: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `ApplicationSettings`
pub mod application_settings {
    // @@protoc_insertion_point(message:fx.ipc.proto.ApplicationSettings.SubtitleSettings)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SubtitleSettings {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettings.SubtitleSettings.directory)
        pub directory: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettings.SubtitleSettings.auto_cleaning_enabled)
        pub auto_cleaning_enabled: bool,
        // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettings.SubtitleSettings.default_subtitle)
        pub default_subtitle: ::protobuf::EnumOrUnknown<super::super::subtitle::subtitle::Language>,
        // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettings.SubtitleSettings.font_family)
        pub font_family: ::protobuf::EnumOrUnknown<subtitle_settings::Family>,
        // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettings.SubtitleSettings.font_size)
        pub font_size: i32,
        // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettings.SubtitleSettings.decoration)
        pub decoration: ::protobuf::EnumOrUnknown<subtitle_settings::DecorationType>,
        // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettings.SubtitleSettings.bold)
        pub bold: bool,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.ApplicationSettings.SubtitleSettings.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SubtitleSettings {
        fn default() -> &'a SubtitleSettings {
            <SubtitleSettings as ::protobuf::Message>::default_instance()
        }
    }

    impl SubtitleSettings {
        pub fn new() -> SubtitleSettings {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for SubtitleSettings {
        const NAME: &'static str = "SubtitleSettings";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.directory = is.read_string()?;
                    },
                    16 => {
                        self.auto_cleaning_enabled = is.read_bool()?;
                    },
                    24 => {
                        self.default_subtitle = is.read_enum_or_unknown()?;
                    },
                    32 => {
                        self.font_family = is.read_enum_or_unknown()?;
                    },
                    40 => {
                        self.font_size = is.read_int32()?;
                    },
                    48 => {
                        self.decoration = is.read_enum_or_unknown()?;
                    },
                    56 => {
                        self.bold = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.directory.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.directory);
            }
            if self.auto_cleaning_enabled != false {
                my_size += 1 + 1;
            }
            if self.default_subtitle != ::protobuf::EnumOrUnknown::new(super::super::subtitle::subtitle::Language::NONE) {
                my_size += ::protobuf::rt::int32_size(3, self.default_subtitle.value());
            }
            if self.font_family != ::protobuf::EnumOrUnknown::new(subtitle_settings::Family::ARIAL) {
                my_size += ::protobuf::rt::int32_size(4, self.font_family.value());
            }
            if self.font_size != 0 {
                my_size += ::protobuf::rt::int32_size(5, self.font_size);
            }
            if self.decoration != ::protobuf::EnumOrUnknown::new(subtitle_settings::DecorationType::NONE) {
                my_size += ::protobuf::rt::int32_size(6, self.decoration.value());
            }
            if self.bold != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.directory.is_empty() {
                os.write_string(1, &self.directory)?;
            }
            if self.auto_cleaning_enabled != false {
                os.write_bool(2, self.auto_cleaning_enabled)?;
            }
            if self.default_subtitle != ::protobuf::EnumOrUnknown::new(super::super::subtitle::subtitle::Language::NONE) {
                os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.default_subtitle))?;
            }
            if self.font_family != ::protobuf::EnumOrUnknown::new(subtitle_settings::Family::ARIAL) {
                os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.font_family))?;
            }
            if self.font_size != 0 {
                os.write_int32(5, self.font_size)?;
            }
            if self.decoration != ::protobuf::EnumOrUnknown::new(subtitle_settings::DecorationType::NONE) {
                os.write_enum(6, ::protobuf::EnumOrUnknown::value(&self.decoration))?;
            }
            if self.bold != false {
                os.write_bool(7, self.bold)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SubtitleSettings {
            SubtitleSettings::new()
        }

        fn clear(&mut self) {
            self.directory.clear();
            self.auto_cleaning_enabled = false;
            self.default_subtitle = ::protobuf::EnumOrUnknown::new(super::super::subtitle::subtitle::Language::NONE);
            self.font_family = ::protobuf::EnumOrUnknown::new(subtitle_settings::Family::ARIAL);
            self.font_size = 0;
            self.decoration = ::protobuf::EnumOrUnknown::new(subtitle_settings::DecorationType::NONE);
            self.bold = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SubtitleSettings {
            static instance: SubtitleSettings = SubtitleSettings {
                directory: ::std::string::String::new(),
                auto_cleaning_enabled: false,
                default_subtitle: ::protobuf::EnumOrUnknown::from_i32(0),
                font_family: ::protobuf::EnumOrUnknown::from_i32(0),
                font_size: 0,
                decoration: ::protobuf::EnumOrUnknown::from_i32(0),
                bold: false,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `SubtitleSettings`
    pub mod subtitle_settings {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:fx.ipc.proto.ApplicationSettings.SubtitleSettings.Family)
        pub enum Family {
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.ApplicationSettings.SubtitleSettings.Family.ARIAL)
            ARIAL = 0,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.ApplicationSettings.SubtitleSettings.Family.COMIC_SANS)
            COMIC_SANS = 1,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.ApplicationSettings.SubtitleSettings.Family.GEORGIA)
            GEORGIA = 2,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.ApplicationSettings.SubtitleSettings.Family.TAHOMA)
            TAHOMA = 3,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.ApplicationSettings.SubtitleSettings.Family.TREBUCHET_MS)
            TREBUCHET_MS = 4,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.ApplicationSettings.SubtitleSettings.Family.VERDANA)
            VERDANA = 5,
        }

        impl ::protobuf::Enum for Family {
            const NAME: &'static str = "Family";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<Family> {
                match value {
                    0 => ::std::option::Option::Some(Family::ARIAL),
                    1 => ::std::option::Option::Some(Family::COMIC_SANS),
                    2 => ::std::option::Option::Some(Family::GEORGIA),
                    3 => ::std::option::Option::Some(Family::TAHOMA),
                    4 => ::std::option::Option::Some(Family::TREBUCHET_MS),
                    5 => ::std::option::Option::Some(Family::VERDANA),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<Family> {
                match str {
                    "ARIAL" => ::std::option::Option::Some(Family::ARIAL),
                    "COMIC_SANS" => ::std::option::Option::Some(Family::COMIC_SANS),
                    "GEORGIA" => ::std::option::Option::Some(Family::GEORGIA),
                    "TAHOMA" => ::std::option::Option::Some(Family::TAHOMA),
                    "TREBUCHET_MS" => ::std::option::Option::Some(Family::TREBUCHET_MS),
                    "VERDANA" => ::std::option::Option::Some(Family::VERDANA),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [Family] = &[
                Family::ARIAL,
                Family::COMIC_SANS,
                Family::GEORGIA,
                Family::TAHOMA,
                Family::TREBUCHET_MS,
                Family::VERDANA,
            ];
        }

        impl ::std::default::Default for Family {
            fn default() -> Self {
                Family::ARIAL
            }
        }


        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:fx.ipc.proto.ApplicationSettings.SubtitleSettings.DecorationType)
        pub enum DecorationType {
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.ApplicationSettings.SubtitleSettings.DecorationType.NONE)
            NONE = 0,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.ApplicationSettings.SubtitleSettings.DecorationType.OUTLINE)
            OUTLINE = 1,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.ApplicationSettings.SubtitleSettings.DecorationType.OPAQUE_BACKGROUND)
            OPAQUE_BACKGROUND = 2,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.ApplicationSettings.SubtitleSettings.DecorationType.SEE_THROUGH_BACKGROUND)
            SEE_THROUGH_BACKGROUND = 3,
        }

        impl ::protobuf::Enum for DecorationType {
            const NAME: &'static str = "DecorationType";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<DecorationType> {
                match value {
                    0 => ::std::option::Option::Some(DecorationType::NONE),
                    1 => ::std::option::Option::Some(DecorationType::OUTLINE),
                    2 => ::std::option::Option::Some(DecorationType::OPAQUE_BACKGROUND),
                    3 => ::std::option::Option::Some(DecorationType::SEE_THROUGH_BACKGROUND),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<DecorationType> {
                match str {
                    "NONE" => ::std::option::Option::Some(DecorationType::NONE),
                    "OUTLINE" => ::std::option::Option::Some(DecorationType::OUTLINE),
                    "OPAQUE_BACKGROUND" => ::std::option::Option::Some(DecorationType::OPAQUE_BACKGROUND),
                    "SEE_THROUGH_BACKGROUND" => ::std::option::Option::Some(DecorationType::SEE_THROUGH_BACKGROUND),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [DecorationType] = &[
                DecorationType::NONE,
                DecorationType::OUTLINE,
                DecorationType::OPAQUE_BACKGROUND,
                DecorationType::SEE_THROUGH_BACKGROUND,
            ];
        }

        impl ::std::default::Default for DecorationType {
            fn default() -> Self {
                DecorationType::NONE
            }
        }

    }

    // @@protoc_insertion_point(message:fx.ipc.proto.ApplicationSettings.TorrentSettings)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TorrentSettings {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettings.TorrentSettings.directory)
        pub directory: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettings.TorrentSettings.cleaning_mode)
        pub cleaning_mode: ::protobuf::EnumOrUnknown<torrent_settings::CleaningMode>,
        // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettings.TorrentSettings.connections_limit)
        pub connections_limit: u32,
        // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettings.TorrentSettings.download_rate_limit)
        pub download_rate_limit: u32,
        // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettings.TorrentSettings.upload_rate_limit)
        pub upload_rate_limit: u32,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.ApplicationSettings.TorrentSettings.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TorrentSettings {
        fn default() -> &'a TorrentSettings {
            <TorrentSettings as ::protobuf::Message>::default_instance()
        }
    }

    impl TorrentSettings {
        pub fn new() -> TorrentSettings {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for TorrentSettings {
        const NAME: &'static str = "TorrentSettings";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.directory = is.read_string()?;
                    },
                    16 => {
                        self.cleaning_mode = is.read_enum_or_unknown()?;
                    },
                    24 => {
                        self.connections_limit = is.read_uint32()?;
                    },
                    32 => {
                        self.download_rate_limit = is.read_uint32()?;
                    },
                    40 => {
                        self.upload_rate_limit = is.read_uint32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.directory.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.directory);
            }
            if self.cleaning_mode != ::protobuf::EnumOrUnknown::new(torrent_settings::CleaningMode::OFF) {
                my_size += ::protobuf::rt::int32_size(2, self.cleaning_mode.value());
            }
            if self.connections_limit != 0 {
                my_size += ::protobuf::rt::uint32_size(3, self.connections_limit);
            }
            if self.download_rate_limit != 0 {
                my_size += ::protobuf::rt::uint32_size(4, self.download_rate_limit);
            }
            if self.upload_rate_limit != 0 {
                my_size += ::protobuf::rt::uint32_size(5, self.upload_rate_limit);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.directory.is_empty() {
                os.write_string(1, &self.directory)?;
            }
            if self.cleaning_mode != ::protobuf::EnumOrUnknown::new(torrent_settings::CleaningMode::OFF) {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.cleaning_mode))?;
            }
            if self.connections_limit != 0 {
                os.write_uint32(3, self.connections_limit)?;
            }
            if self.download_rate_limit != 0 {
                os.write_uint32(4, self.download_rate_limit)?;
            }
            if self.upload_rate_limit != 0 {
                os.write_uint32(5, self.upload_rate_limit)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TorrentSettings {
            TorrentSettings::new()
        }

        fn clear(&mut self) {
            self.directory.clear();
            self.cleaning_mode = ::protobuf::EnumOrUnknown::new(torrent_settings::CleaningMode::OFF);
            self.connections_limit = 0;
            self.download_rate_limit = 0;
            self.upload_rate_limit = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TorrentSettings {
            static instance: TorrentSettings = TorrentSettings {
                directory: ::std::string::String::new(),
                cleaning_mode: ::protobuf::EnumOrUnknown::from_i32(0),
                connections_limit: 0,
                download_rate_limit: 0,
                upload_rate_limit: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `TorrentSettings`
    pub mod torrent_settings {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:fx.ipc.proto.ApplicationSettings.TorrentSettings.CleaningMode)
        pub enum CleaningMode {
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.ApplicationSettings.TorrentSettings.CleaningMode.OFF)
            OFF = 0,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.ApplicationSettings.TorrentSettings.CleaningMode.ON_SHUTDOWN)
            ON_SHUTDOWN = 1,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.ApplicationSettings.TorrentSettings.CleaningMode.WATCHED)
            WATCHED = 2,
        }

        impl ::protobuf::Enum for CleaningMode {
            const NAME: &'static str = "CleaningMode";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<CleaningMode> {
                match value {
                    0 => ::std::option::Option::Some(CleaningMode::OFF),
                    1 => ::std::option::Option::Some(CleaningMode::ON_SHUTDOWN),
                    2 => ::std::option::Option::Some(CleaningMode::WATCHED),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<CleaningMode> {
                match str {
                    "OFF" => ::std::option::Option::Some(CleaningMode::OFF),
                    "ON_SHUTDOWN" => ::std::option::Option::Some(CleaningMode::ON_SHUTDOWN),
                    "WATCHED" => ::std::option::Option::Some(CleaningMode::WATCHED),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [CleaningMode] = &[
                CleaningMode::OFF,
                CleaningMode::ON_SHUTDOWN,
                CleaningMode::WATCHED,
            ];
        }

        impl ::std::default::Default for CleaningMode {
            fn default() -> Self {
                CleaningMode::OFF
            }
        }

    }

    // @@protoc_insertion_point(message:fx.ipc.proto.ApplicationSettings.UISettings)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UISettings {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettings.UISettings.default_language)
        pub default_language: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettings.UISettings.scale)
        pub scale: ::protobuf::MessageField<uisettings::Scale>,
        // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettings.UISettings.start_screen)
        pub start_screen: ::protobuf::EnumOrUnknown<super::super::media::media::Category>,
        // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettings.UISettings.maximized)
        pub maximized: bool,
        // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettings.UISettings.native_window_enabled)
        pub native_window_enabled: bool,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.ApplicationSettings.UISettings.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UISettings {
        fn default() -> &'a UISettings {
            <UISettings as ::protobuf::Message>::default_instance()
        }
    }

    impl UISettings {
        pub fn new() -> UISettings {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for UISettings {
        const NAME: &'static str = "UISettings";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.default_language = is.read_string()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.scale)?;
                    },
                    24 => {
                        self.start_screen = is.read_enum_or_unknown()?;
                    },
                    32 => {
                        self.maximized = is.read_bool()?;
                    },
                    40 => {
                        self.native_window_enabled = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.default_language.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.default_language);
            }
            if let Some(v) = self.scale.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.start_screen != ::protobuf::EnumOrUnknown::new(super::super::media::media::Category::MOVIES) {
                my_size += ::protobuf::rt::int32_size(3, self.start_screen.value());
            }
            if self.maximized != false {
                my_size += 1 + 1;
            }
            if self.native_window_enabled != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.default_language.is_empty() {
                os.write_string(1, &self.default_language)?;
            }
            if let Some(v) = self.scale.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if self.start_screen != ::protobuf::EnumOrUnknown::new(super::super::media::media::Category::MOVIES) {
                os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.start_screen))?;
            }
            if self.maximized != false {
                os.write_bool(4, self.maximized)?;
            }
            if self.native_window_enabled != false {
                os.write_bool(5, self.native_window_enabled)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UISettings {
            UISettings::new()
        }

        fn clear(&mut self) {
            self.default_language.clear();
            self.scale.clear();
            self.start_screen = ::protobuf::EnumOrUnknown::new(super::super::media::media::Category::MOVIES);
            self.maximized = false;
            self.native_window_enabled = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UISettings {
            static instance: UISettings = UISettings {
                default_language: ::std::string::String::new(),
                scale: ::protobuf::MessageField::none(),
                start_screen: ::protobuf::EnumOrUnknown::from_i32(0),
                maximized: false,
                native_window_enabled: false,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `UISettings`
    pub mod uisettings {
        // @@protoc_insertion_point(message:fx.ipc.proto.ApplicationSettings.UISettings.Scale)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Scale {
            // message fields
            // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettings.UISettings.Scale.factor)
            pub factor: f32,
            // special fields
            // @@protoc_insertion_point(special_field:fx.ipc.proto.ApplicationSettings.UISettings.Scale.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Scale {
            fn default() -> &'a Scale {
                <Scale as ::protobuf::Message>::default_instance()
            }
        }

        impl Scale {
            pub fn new() -> Scale {
                ::std::default::Default::default()
            }
        }

        impl ::protobuf::Message for Scale {
            const NAME: &'static str = "Scale";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        13 => {
                            self.factor = is.read_float()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.factor != 0. {
                    my_size += 1 + 4;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.factor != 0. {
                    os.write_float(1, self.factor)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Scale {
                Scale::new()
            }

            fn clear(&mut self) {
                self.factor = 0.;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Scale {
                static instance: Scale = Scale {
                    factor: 0.,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }

    // @@protoc_insertion_point(message:fx.ipc.proto.ApplicationSettings.ServerSettings)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ServerSettings {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettings.ServerSettings.api_server)
        pub api_server: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.ApplicationSettings.ServerSettings.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ServerSettings {
        fn default() -> &'a ServerSettings {
            <ServerSettings as ::protobuf::Message>::default_instance()
        }
    }

    impl ServerSettings {
        pub fn new() -> ServerSettings {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for ServerSettings {
        const NAME: &'static str = "ServerSettings";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.api_server = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.api_server.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.api_server.as_ref() {
                os.write_string(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ServerSettings {
            ServerSettings::new()
        }

        fn clear(&mut self) {
            self.api_server = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ServerSettings {
            static instance: ServerSettings = ServerSettings {
                api_server: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:fx.ipc.proto.ApplicationSettings.PlaybackSettings)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlaybackSettings {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettings.PlaybackSettings.quality)
        pub quality: ::std::option::Option<::protobuf::EnumOrUnknown<playback_settings::Quality>>,
        // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettings.PlaybackSettings.fullscreen)
        pub fullscreen: bool,
        // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettings.PlaybackSettings.auto_play_next_episode_enabled)
        pub auto_play_next_episode_enabled: bool,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.ApplicationSettings.PlaybackSettings.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlaybackSettings {
        fn default() -> &'a PlaybackSettings {
            <PlaybackSettings as ::protobuf::Message>::default_instance()
        }
    }

    impl PlaybackSettings {
        pub fn new() -> PlaybackSettings {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for PlaybackSettings {
        const NAME: &'static str = "PlaybackSettings";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.quality = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    16 => {
                        self.fullscreen = is.read_bool()?;
                    },
                    24 => {
                        self.auto_play_next_episode_enabled = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.quality {
                my_size += ::protobuf::rt::int32_size(1, v.value());
            }
            if self.fullscreen != false {
                my_size += 1 + 1;
            }
            if self.auto_play_next_episode_enabled != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.quality {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if self.fullscreen != false {
                os.write_bool(2, self.fullscreen)?;
            }
            if self.auto_play_next_episode_enabled != false {
                os.write_bool(3, self.auto_play_next_episode_enabled)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlaybackSettings {
            PlaybackSettings::new()
        }

        fn clear(&mut self) {
            self.quality = ::std::option::Option::None;
            self.fullscreen = false;
            self.auto_play_next_episode_enabled = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlaybackSettings {
            static instance: PlaybackSettings = PlaybackSettings {
                quality: ::std::option::Option::None,
                fullscreen: false,
                auto_play_next_episode_enabled: false,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `PlaybackSettings`
    pub mod playback_settings {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:fx.ipc.proto.ApplicationSettings.PlaybackSettings.Quality)
        pub enum Quality {
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.ApplicationSettings.PlaybackSettings.Quality.P0)
            P0 = 0,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.ApplicationSettings.PlaybackSettings.Quality.P480)
            P480 = 480,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.ApplicationSettings.PlaybackSettings.Quality.P720)
            P720 = 720,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.ApplicationSettings.PlaybackSettings.Quality.P1080)
            P1080 = 1080,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.ApplicationSettings.PlaybackSettings.Quality.P2160)
            P2160 = 2160,
        }

        impl ::protobuf::Enum for Quality {
            const NAME: &'static str = "Quality";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<Quality> {
                match value {
                    0 => ::std::option::Option::Some(Quality::P0),
                    480 => ::std::option::Option::Some(Quality::P480),
                    720 => ::std::option::Option::Some(Quality::P720),
                    1080 => ::std::option::Option::Some(Quality::P1080),
                    2160 => ::std::option::Option::Some(Quality::P2160),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<Quality> {
                match str {
                    "P0" => ::std::option::Option::Some(Quality::P0),
                    "P480" => ::std::option::Option::Some(Quality::P480),
                    "P720" => ::std::option::Option::Some(Quality::P720),
                    "P1080" => ::std::option::Option::Some(Quality::P1080),
                    "P2160" => ::std::option::Option::Some(Quality::P2160),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [Quality] = &[
                Quality::P0,
                Quality::P480,
                Quality::P720,
                Quality::P1080,
                Quality::P2160,
            ];
        }

        impl ::std::default::Default for Quality {
            fn default() -> Self {
                Quality::P0
            }
        }

    }

    // @@protoc_insertion_point(message:fx.ipc.proto.ApplicationSettings.TrackingSettings)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TrackingSettings {
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.ApplicationSettings.TrackingSettings.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TrackingSettings {
        fn default() -> &'a TrackingSettings {
            <TrackingSettings as ::protobuf::Message>::default_instance()
        }
    }

    impl TrackingSettings {
        pub fn new() -> TrackingSettings {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for TrackingSettings {
        const NAME: &'static str = "TrackingSettings";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TrackingSettings {
            TrackingSettings::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TrackingSettings {
            static instance: TrackingSettings = TrackingSettings {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.UpdateTorrentSettingsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpdateTorrentSettingsRequest {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.UpdateTorrentSettingsRequest.settings)
    pub settings: ::protobuf::MessageField<application_settings::TorrentSettings>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.UpdateTorrentSettingsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateTorrentSettingsRequest {
    fn default() -> &'a UpdateTorrentSettingsRequest {
        <UpdateTorrentSettingsRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateTorrentSettingsRequest {
    pub fn new() -> UpdateTorrentSettingsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdateTorrentSettingsRequest {
    const NAME: &'static str = "UpdateTorrentSettingsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.settings)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateTorrentSettingsRequest {
        UpdateTorrentSettingsRequest::new()
    }

    fn clear(&mut self) {
        self.settings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateTorrentSettingsRequest {
        static instance: UpdateTorrentSettingsRequest = UpdateTorrentSettingsRequest {
            settings: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.UpdateSubtitleSettingsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpdateSubtitleSettingsRequest {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.UpdateSubtitleSettingsRequest.settings)
    pub settings: ::protobuf::MessageField<application_settings::SubtitleSettings>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.UpdateSubtitleSettingsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateSubtitleSettingsRequest {
    fn default() -> &'a UpdateSubtitleSettingsRequest {
        <UpdateSubtitleSettingsRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateSubtitleSettingsRequest {
    pub fn new() -> UpdateSubtitleSettingsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdateSubtitleSettingsRequest {
    const NAME: &'static str = "UpdateSubtitleSettingsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.settings)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateSubtitleSettingsRequest {
        UpdateSubtitleSettingsRequest::new()
    }

    fn clear(&mut self) {
        self.settings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateSubtitleSettingsRequest {
        static instance: UpdateSubtitleSettingsRequest = UpdateSubtitleSettingsRequest {
            settings: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.UpdateUISettingsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpdateUISettingsRequest {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.UpdateUISettingsRequest.settings)
    pub settings: ::protobuf::MessageField<application_settings::UISettings>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.UpdateUISettingsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateUISettingsRequest {
    fn default() -> &'a UpdateUISettingsRequest {
        <UpdateUISettingsRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateUISettingsRequest {
    pub fn new() -> UpdateUISettingsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdateUISettingsRequest {
    const NAME: &'static str = "UpdateUISettingsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.settings)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateUISettingsRequest {
        UpdateUISettingsRequest::new()
    }

    fn clear(&mut self) {
        self.settings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateUISettingsRequest {
        static instance: UpdateUISettingsRequest = UpdateUISettingsRequest {
            settings: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.UpdateServerSettingsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpdateServerSettingsRequest {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.UpdateServerSettingsRequest.settings)
    pub settings: ::protobuf::MessageField<application_settings::ServerSettings>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.UpdateServerSettingsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateServerSettingsRequest {
    fn default() -> &'a UpdateServerSettingsRequest {
        <UpdateServerSettingsRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateServerSettingsRequest {
    pub fn new() -> UpdateServerSettingsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdateServerSettingsRequest {
    const NAME: &'static str = "UpdateServerSettingsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.settings)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateServerSettingsRequest {
        UpdateServerSettingsRequest::new()
    }

    fn clear(&mut self) {
        self.settings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateServerSettingsRequest {
        static instance: UpdateServerSettingsRequest = UpdateServerSettingsRequest {
            settings: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.UpdatePlaybackSettingsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpdatePlaybackSettingsRequest {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.UpdatePlaybackSettingsRequest.settings)
    pub settings: ::protobuf::MessageField<application_settings::PlaybackSettings>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.UpdatePlaybackSettingsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdatePlaybackSettingsRequest {
    fn default() -> &'a UpdatePlaybackSettingsRequest {
        <UpdatePlaybackSettingsRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdatePlaybackSettingsRequest {
    pub fn new() -> UpdatePlaybackSettingsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdatePlaybackSettingsRequest {
    const NAME: &'static str = "UpdatePlaybackSettingsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.settings)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdatePlaybackSettingsRequest {
        UpdatePlaybackSettingsRequest::new()
    }

    fn clear(&mut self) {
        self.settings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdatePlaybackSettingsRequest {
        static instance: UpdatePlaybackSettingsRequest = UpdatePlaybackSettingsRequest {
            settings: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.ApplicationSettingsEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ApplicationSettingsEvent {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettingsEvent.event)
    pub event: ::protobuf::EnumOrUnknown<application_settings_event::Event>,
    // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettingsEvent.subtitle_settings)
    pub subtitle_settings: ::protobuf::MessageField<application_settings::SubtitleSettings>,
    // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettingsEvent.torrent_settings)
    pub torrent_settings: ::protobuf::MessageField<application_settings::TorrentSettings>,
    // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettingsEvent.ui_settings)
    pub ui_settings: ::protobuf::MessageField<application_settings::UISettings>,
    // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettingsEvent.server_settings)
    pub server_settings: ::protobuf::MessageField<application_settings::ServerSettings>,
    // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettingsEvent.playback_settings)
    pub playback_settings: ::protobuf::MessageField<application_settings::PlaybackSettings>,
    // @@protoc_insertion_point(field:fx.ipc.proto.ApplicationSettingsEvent.tracking_settings)
    pub tracking_settings: ::protobuf::MessageField<application_settings::TrackingSettings>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.ApplicationSettingsEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ApplicationSettingsEvent {
    fn default() -> &'a ApplicationSettingsEvent {
        <ApplicationSettingsEvent as ::protobuf::Message>::default_instance()
    }
}

impl ApplicationSettingsEvent {
    pub fn new() -> ApplicationSettingsEvent {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ApplicationSettingsEvent {
    const NAME: &'static str = "ApplicationSettingsEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.subtitle_settings)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.torrent_settings)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ui_settings)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.server_settings)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.playback_settings)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tracking_settings)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.event != ::protobuf::EnumOrUnknown::new(application_settings_event::Event::LOADED) {
            my_size += ::protobuf::rt::int32_size(1, self.event.value());
        }
        if let Some(v) = self.subtitle_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.torrent_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ui_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.server_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.playback_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tracking_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.event != ::protobuf::EnumOrUnknown::new(application_settings_event::Event::LOADED) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.event))?;
        }
        if let Some(v) = self.subtitle_settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.torrent_settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.ui_settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.server_settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.playback_settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.tracking_settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ApplicationSettingsEvent {
        ApplicationSettingsEvent::new()
    }

    fn clear(&mut self) {
        self.event = ::protobuf::EnumOrUnknown::new(application_settings_event::Event::LOADED);
        self.subtitle_settings.clear();
        self.torrent_settings.clear();
        self.ui_settings.clear();
        self.server_settings.clear();
        self.playback_settings.clear();
        self.tracking_settings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ApplicationSettingsEvent {
        static instance: ApplicationSettingsEvent = ApplicationSettingsEvent {
            event: ::protobuf::EnumOrUnknown::from_i32(0),
            subtitle_settings: ::protobuf::MessageField::none(),
            torrent_settings: ::protobuf::MessageField::none(),
            ui_settings: ::protobuf::MessageField::none(),
            server_settings: ::protobuf::MessageField::none(),
            playback_settings: ::protobuf::MessageField::none(),
            tracking_settings: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `ApplicationSettingsEvent`
pub mod application_settings_event {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:fx.ipc.proto.ApplicationSettingsEvent.Event)
    pub enum Event {
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.ApplicationSettingsEvent.Event.LOADED)
        LOADED = 0,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.ApplicationSettingsEvent.Event.SAVED)
        SAVED = 1,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.ApplicationSettingsEvent.Event.SUBTITLE_SETTINGS_CHANGED)
        SUBTITLE_SETTINGS_CHANGED = 2,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.ApplicationSettingsEvent.Event.TORRENT_SETTINGS_CHANGED)
        TORRENT_SETTINGS_CHANGED = 3,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.ApplicationSettingsEvent.Event.UI_SETTINGS_CHANGED)
        UI_SETTINGS_CHANGED = 4,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.ApplicationSettingsEvent.Event.SERVER_SETTINGS_CHANGED)
        SERVER_SETTINGS_CHANGED = 5,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.ApplicationSettingsEvent.Event.PLAYBACK_SETTINGS_CHANGED)
        PLAYBACK_SETTINGS_CHANGED = 6,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.ApplicationSettingsEvent.Event.TRACKING_SETTINGS_CHANGED)
        TRACKING_SETTINGS_CHANGED = 7,
    }

    impl ::protobuf::Enum for Event {
        const NAME: &'static str = "Event";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Event> {
            match value {
                0 => ::std::option::Option::Some(Event::LOADED),
                1 => ::std::option::Option::Some(Event::SAVED),
                2 => ::std::option::Option::Some(Event::SUBTITLE_SETTINGS_CHANGED),
                3 => ::std::option::Option::Some(Event::TORRENT_SETTINGS_CHANGED),
                4 => ::std::option::Option::Some(Event::UI_SETTINGS_CHANGED),
                5 => ::std::option::Option::Some(Event::SERVER_SETTINGS_CHANGED),
                6 => ::std::option::Option::Some(Event::PLAYBACK_SETTINGS_CHANGED),
                7 => ::std::option::Option::Some(Event::TRACKING_SETTINGS_CHANGED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Event> {
            match str {
                "LOADED" => ::std::option::Option::Some(Event::LOADED),
                "SAVED" => ::std::option::Option::Some(Event::SAVED),
                "SUBTITLE_SETTINGS_CHANGED" => ::std::option::Option::Some(Event::SUBTITLE_SETTINGS_CHANGED),
                "TORRENT_SETTINGS_CHANGED" => ::std::option::Option::Some(Event::TORRENT_SETTINGS_CHANGED),
                "UI_SETTINGS_CHANGED" => ::std::option::Option::Some(Event::UI_SETTINGS_CHANGED),
                "SERVER_SETTINGS_CHANGED" => ::std::option::Option::Some(Event::SERVER_SETTINGS_CHANGED),
                "PLAYBACK_SETTINGS_CHANGED" => ::std::option::Option::Some(Event::PLAYBACK_SETTINGS_CHANGED),
                "TRACKING_SETTINGS_CHANGED" => ::std::option::Option::Some(Event::TRACKING_SETTINGS_CHANGED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Event] = &[
            Event::LOADED,
            Event::SAVED,
            Event::SUBTITLE_SETTINGS_CHANGED,
            Event::TORRENT_SETTINGS_CHANGED,
            Event::UI_SETTINGS_CHANGED,
            Event::SERVER_SETTINGS_CHANGED,
            Event::PLAYBACK_SETTINGS_CHANGED,
            Event::TRACKING_SETTINGS_CHANGED,
        ];
    }

    impl ::std::default::Default for Event {
        fn default() -> Self {
            Event::LOADED
        }
    }

}
