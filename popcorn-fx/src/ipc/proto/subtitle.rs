// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by protoc 33.2
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `subtitle.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

// @@protoc_insertion_point(message:fx.ipc.proto.SubtitlePreference)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubtitlePreference {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.SubtitlePreference.preference)
    pub preference: ::protobuf::EnumOrUnknown<subtitle_preference::Preference>,
    // @@protoc_insertion_point(field:fx.ipc.proto.SubtitlePreference.language)
    pub language: ::std::option::Option<::protobuf::EnumOrUnknown<subtitle::Language>>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.SubtitlePreference.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubtitlePreference {
    fn default() -> &'a SubtitlePreference {
        <SubtitlePreference as ::protobuf::Message>::default_instance()
    }
}

impl SubtitlePreference {
    pub fn new() -> SubtitlePreference {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubtitlePreference {
    const NAME: &'static str = "SubtitlePreference";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.preference = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.language = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.preference != ::protobuf::EnumOrUnknown::new(subtitle_preference::Preference::LANGUAGE) {
            my_size += ::protobuf::rt::int32_size(1, self.preference.value());
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.preference != ::protobuf::EnumOrUnknown::new(subtitle_preference::Preference::LANGUAGE) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.preference))?;
        }
        if let Some(v) = self.language {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubtitlePreference {
        SubtitlePreference::new()
    }

    fn clear(&mut self) {
        self.preference = ::protobuf::EnumOrUnknown::new(subtitle_preference::Preference::LANGUAGE);
        self.language = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubtitlePreference {
        static instance: SubtitlePreference = SubtitlePreference {
            preference: ::protobuf::EnumOrUnknown::from_i32(0),
            language: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `SubtitlePreference`
pub mod subtitle_preference {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:fx.ipc.proto.SubtitlePreference.Preference)
    pub enum Preference {
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.SubtitlePreference.Preference.LANGUAGE)
        LANGUAGE = 0,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.SubtitlePreference.Preference.DISABLED)
        DISABLED = 1,
    }

    impl ::protobuf::Enum for Preference {
        const NAME: &'static str = "Preference";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Preference> {
            match value {
                0 => ::std::option::Option::Some(Preference::LANGUAGE),
                1 => ::std::option::Option::Some(Preference::DISABLED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Preference> {
            match str {
                "LANGUAGE" => ::std::option::Option::Some(Preference::LANGUAGE),
                "DISABLED" => ::std::option::Option::Some(Preference::DISABLED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Preference] = &[
            Preference::LANGUAGE,
            Preference::DISABLED,
        ];
    }

    impl ::std::default::Default for Preference {
        fn default() -> Self {
            Preference::LANGUAGE
        }
    }

}

// @@protoc_insertion_point(message:fx.ipc.proto.SubtitleChangedEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubtitleChangedEvent {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.SubtitleChangedEvent.event)
    pub event: ::protobuf::EnumOrUnknown<subtitle_changed_event::Event>,
    // @@protoc_insertion_point(field:fx.ipc.proto.SubtitleChangedEvent.info)
    pub info: ::protobuf::MessageField<subtitle::Info>,
    // @@protoc_insertion_point(field:fx.ipc.proto.SubtitleChangedEvent.preferred_language)
    pub preferred_language: ::std::option::Option<::protobuf::EnumOrUnknown<subtitle::Language>>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.SubtitleChangedEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubtitleChangedEvent {
    fn default() -> &'a SubtitleChangedEvent {
        <SubtitleChangedEvent as ::protobuf::Message>::default_instance()
    }
}

impl SubtitleChangedEvent {
    pub fn new() -> SubtitleChangedEvent {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubtitleChangedEvent {
    const NAME: &'static str = "SubtitleChangedEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                24 => {
                    self.preferred_language = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.event != ::protobuf::EnumOrUnknown::new(subtitle_changed_event::Event::InfoChanged) {
            my_size += ::protobuf::rt::int32_size(1, self.event.value());
        }
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.preferred_language {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.event != ::protobuf::EnumOrUnknown::new(subtitle_changed_event::Event::InfoChanged) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.event))?;
        }
        if let Some(v) = self.info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.preferred_language {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubtitleChangedEvent {
        SubtitleChangedEvent::new()
    }

    fn clear(&mut self) {
        self.event = ::protobuf::EnumOrUnknown::new(subtitle_changed_event::Event::InfoChanged);
        self.info.clear();
        self.preferred_language = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubtitleChangedEvent {
        static instance: SubtitleChangedEvent = SubtitleChangedEvent {
            event: ::protobuf::EnumOrUnknown::from_i32(0),
            info: ::protobuf::MessageField::none(),
            preferred_language: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `SubtitleChangedEvent`
pub mod subtitle_changed_event {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:fx.ipc.proto.SubtitleChangedEvent.Event)
    pub enum Event {
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.SubtitleChangedEvent.Event.InfoChanged)
        InfoChanged = 0,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.SubtitleChangedEvent.Event.LanguageChanged)
        LanguageChanged = 1,
    }

    impl ::protobuf::Enum for Event {
        const NAME: &'static str = "Event";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Event> {
            match value {
                0 => ::std::option::Option::Some(Event::InfoChanged),
                1 => ::std::option::Option::Some(Event::LanguageChanged),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Event> {
            match str {
                "InfoChanged" => ::std::option::Option::Some(Event::InfoChanged),
                "LanguageChanged" => ::std::option::Option::Some(Event::LanguageChanged),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Event] = &[
            Event::InfoChanged,
            Event::LanguageChanged,
        ];
    }

    impl ::std::default::Default for Event {
        fn default() -> Self {
            Event::InfoChanged
        }
    }

}

// @@protoc_insertion_point(message:fx.ipc.proto.Subtitle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Subtitle {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.file_path)
    pub file_path: ::std::string::String,
    // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.info)
    pub info: ::protobuf::MessageField<subtitle::Info>,
    // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.cues)
    pub cues: ::std::vec::Vec<subtitle::Cue>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.Subtitle.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Subtitle {
    fn default() -> &'a Subtitle {
        <Subtitle as ::protobuf::Message>::default_instance()
    }
}

impl Subtitle {
    pub fn new() -> Subtitle {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Subtitle {
    const NAME: &'static str = "Subtitle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.file_path = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                26 => {
                    self.cues.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.file_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.file_path);
        }
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.cues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.file_path.is_empty() {
            os.write_string(1, &self.file_path)?;
        }
        if let Some(v) = self.info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.cues {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Subtitle {
        Subtitle::new()
    }

    fn clear(&mut self) {
        self.file_path.clear();
        self.info.clear();
        self.cues.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Subtitle {
        static instance: Subtitle = Subtitle {
            file_path: ::std::string::String::new(),
            info: ::protobuf::MessageField::none(),
            cues: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `Subtitle`
pub mod subtitle {
    // @@protoc_insertion_point(message:fx.ipc.proto.Subtitle.Info)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Info {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Info.imdb_id)
        pub imdb_id: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Info.language)
        pub language: ::protobuf::EnumOrUnknown<Language>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Info.files)
        pub files: ::std::vec::Vec<info::File>,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.Subtitle.Info.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Info {
        fn default() -> &'a Info {
            <Info as ::protobuf::Message>::default_instance()
        }
    }

    impl Info {
        pub fn new() -> Info {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for Info {
        const NAME: &'static str = "Info";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.imdb_id = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.language = is.read_enum_or_unknown()?;
                    },
                    26 => {
                        self.files.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.imdb_id.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if self.language != ::protobuf::EnumOrUnknown::new(Language::NONE) {
                my_size += ::protobuf::rt::int32_size(2, self.language.value());
            }
            for value in &self.files {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.imdb_id.as_ref() {
                os.write_string(1, v)?;
            }
            if self.language != ::protobuf::EnumOrUnknown::new(Language::NONE) {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.language))?;
            }
            for v in &self.files {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Info {
            Info::new()
        }

        fn clear(&mut self) {
            self.imdb_id = ::std::option::Option::None;
            self.language = ::protobuf::EnumOrUnknown::new(Language::NONE);
            self.files.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Info {
            static instance: Info = Info {
                imdb_id: ::std::option::Option::None,
                language: ::protobuf::EnumOrUnknown::from_i32(0),
                files: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Info`
    pub mod info {
        // @@protoc_insertion_point(message:fx.ipc.proto.Subtitle.Info.File)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct File {
            // message fields
            // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Info.File.file_id)
            pub file_id: i32,
            // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Info.File.name)
            pub name: ::std::string::String,
            // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Info.File.url)
            pub url: ::std::string::String,
            // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Info.File.score)
            pub score: f32,
            // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Info.File.downloads)
            pub downloads: i32,
            // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Info.File.quality)
            pub quality: ::std::option::Option<i32>,
            // special fields
            // @@protoc_insertion_point(special_field:fx.ipc.proto.Subtitle.Info.File.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a File {
            fn default() -> &'a File {
                <File as ::protobuf::Message>::default_instance()
            }
        }

        impl File {
            pub fn new() -> File {
                ::std::default::Default::default()
            }
        }

        impl ::protobuf::Message for File {
            const NAME: &'static str = "File";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.file_id = is.read_int32()?;
                        },
                        18 => {
                            self.name = is.read_string()?;
                        },
                        26 => {
                            self.url = is.read_string()?;
                        },
                        37 => {
                            self.score = is.read_float()?;
                        },
                        40 => {
                            self.downloads = is.read_int32()?;
                        },
                        48 => {
                            self.quality = ::std::option::Option::Some(is.read_int32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.file_id != 0 {
                    my_size += ::protobuf::rt::int32_size(1, self.file_id);
                }
                if !self.name.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.name);
                }
                if !self.url.is_empty() {
                    my_size += ::protobuf::rt::string_size(3, &self.url);
                }
                if self.score != 0. {
                    my_size += 1 + 4;
                }
                if self.downloads != 0 {
                    my_size += ::protobuf::rt::int32_size(5, self.downloads);
                }
                if let Some(v) = self.quality {
                    my_size += ::protobuf::rt::int32_size(6, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.file_id != 0 {
                    os.write_int32(1, self.file_id)?;
                }
                if !self.name.is_empty() {
                    os.write_string(2, &self.name)?;
                }
                if !self.url.is_empty() {
                    os.write_string(3, &self.url)?;
                }
                if self.score != 0. {
                    os.write_float(4, self.score)?;
                }
                if self.downloads != 0 {
                    os.write_int32(5, self.downloads)?;
                }
                if let Some(v) = self.quality {
                    os.write_int32(6, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> File {
                File::new()
            }

            fn clear(&mut self) {
                self.file_id = 0;
                self.name.clear();
                self.url.clear();
                self.score = 0.;
                self.downloads = 0;
                self.quality = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static File {
                static instance: File = File {
                    file_id: 0,
                    name: ::std::string::String::new(),
                    url: ::std::string::String::new(),
                    score: 0.,
                    downloads: 0,
                    quality: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }

    // @@protoc_insertion_point(message:fx.ipc.proto.Subtitle.Cue)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Cue {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Cue.id)
        pub id: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Cue.start_time)
        pub start_time: u64,
        // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Cue.end_time)
        pub end_time: u64,
        // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Cue.lines)
        pub lines: ::std::vec::Vec<cue::Line>,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.Subtitle.Cue.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Cue {
        fn default() -> &'a Cue {
            <Cue as ::protobuf::Message>::default_instance()
        }
    }

    impl Cue {
        pub fn new() -> Cue {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for Cue {
        const NAME: &'static str = "Cue";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.id = is.read_string()?;
                    },
                    16 => {
                        self.start_time = is.read_uint64()?;
                    },
                    24 => {
                        self.end_time = is.read_uint64()?;
                    },
                    34 => {
                        self.lines.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.id);
            }
            if self.start_time != 0 {
                my_size += ::protobuf::rt::uint64_size(2, self.start_time);
            }
            if self.end_time != 0 {
                my_size += ::protobuf::rt::uint64_size(3, self.end_time);
            }
            for value in &self.lines {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.id.is_empty() {
                os.write_string(1, &self.id)?;
            }
            if self.start_time != 0 {
                os.write_uint64(2, self.start_time)?;
            }
            if self.end_time != 0 {
                os.write_uint64(3, self.end_time)?;
            }
            for v in &self.lines {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Cue {
            Cue::new()
        }

        fn clear(&mut self) {
            self.id.clear();
            self.start_time = 0;
            self.end_time = 0;
            self.lines.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Cue {
            static instance: Cue = Cue {
                id: ::std::string::String::new(),
                start_time: 0,
                end_time: 0,
                lines: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Cue`
    pub mod cue {
        // @@protoc_insertion_point(message:fx.ipc.proto.Subtitle.Cue.Line)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Line {
            // message fields
            // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Cue.Line.text)
            pub text: ::std::vec::Vec<line::Text>,
            // special fields
            // @@protoc_insertion_point(special_field:fx.ipc.proto.Subtitle.Cue.Line.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Line {
            fn default() -> &'a Line {
                <Line as ::protobuf::Message>::default_instance()
            }
        }

        impl Line {
            pub fn new() -> Line {
                ::std::default::Default::default()
            }
        }

        impl ::protobuf::Message for Line {
            const NAME: &'static str = "Line";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.text.push(is.read_message()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.text {
                    let len = value.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.text {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Line {
                Line::new()
            }

            fn clear(&mut self) {
                self.text.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Line {
                static instance: Line = Line {
                    text: ::std::vec::Vec::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        /// Nested message and enums of message `Line`
        pub mod line {
            // @@protoc_insertion_point(message:fx.ipc.proto.Subtitle.Cue.Line.Text)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct Text {
                // message fields
                // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Cue.Line.Text.text)
                pub text: ::std::string::String,
                // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Cue.Line.Text.italic)
                pub italic: bool,
                // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Cue.Line.Text.bold)
                pub bold: bool,
                // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Cue.Line.Text.underline)
                pub underline: bool,
                // special fields
                // @@protoc_insertion_point(special_field:fx.ipc.proto.Subtitle.Cue.Line.Text.special_fields)
                pub special_fields: ::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a Text {
                fn default() -> &'a Text {
                    <Text as ::protobuf::Message>::default_instance()
                }
            }

            impl Text {
                pub fn new() -> Text {
                    ::std::default::Default::default()
                }
            }

            impl ::protobuf::Message for Text {
                const NAME: &'static str = "Text";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => {
                                self.text = is.read_string()?;
                            },
                            16 => {
                                self.italic = is.read_bool()?;
                            },
                            24 => {
                                self.bold = is.read_bool()?;
                            },
                            32 => {
                                self.underline = is.read_bool()?;
                            },
                            tag => {
                                ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if !self.text.is_empty() {
                        my_size += ::protobuf::rt::string_size(1, &self.text);
                    }
                    if self.italic != false {
                        my_size += 1 + 1;
                    }
                    if self.bold != false {
                        my_size += 1 + 1;
                    }
                    if self.underline != false {
                        my_size += 1 + 1;
                    }
                    my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                    if !self.text.is_empty() {
                        os.write_string(1, &self.text)?;
                    }
                    if self.italic != false {
                        os.write_bool(2, self.italic)?;
                    }
                    if self.bold != false {
                        os.write_bool(3, self.bold)?;
                    }
                    if self.underline != false {
                        os.write_bool(4, self.underline)?;
                    }
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> Text {
                    Text::new()
                }

                fn clear(&mut self) {
                    self.text.clear();
                    self.italic = false;
                    self.bold = false;
                    self.underline = false;
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static Text {
                    static instance: Text = Text {
                        text: ::std::string::String::new(),
                        italic: false,
                        bold: false,
                        underline: false,
                        special_fields: ::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }
        }
    }

    // @@protoc_insertion_point(message:fx.ipc.proto.Subtitle.Matcher)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Matcher {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Matcher.filename)
        pub filename: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Matcher.quality)
        pub quality: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.Subtitle.Matcher.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Matcher {
        fn default() -> &'a Matcher {
            <Matcher as ::protobuf::Message>::default_instance()
        }
    }

    impl Matcher {
        pub fn new() -> Matcher {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for Matcher {
        const NAME: &'static str = "Matcher";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.filename = is.read_string()?;
                    },
                    18 => {
                        self.quality = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.filename.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.filename);
            }
            if let Some(v) = self.quality.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.filename.is_empty() {
                os.write_string(1, &self.filename)?;
            }
            if let Some(v) = self.quality.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Matcher {
            Matcher::new()
        }

        fn clear(&mut self) {
            self.filename.clear();
            self.quality = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Matcher {
            static instance: Matcher = Matcher {
                filename: ::std::string::String::new(),
                quality: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:fx.ipc.proto.Subtitle.Error)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Error {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Error.type)
        pub type_: ::protobuf::EnumOrUnknown<error::Type>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Error.invalid_url)
        pub invalid_url: ::protobuf::MessageField<error::InvalidUrl>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Error.search_failed)
        pub search_failed: ::protobuf::MessageField<error::SearchFailed>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Error.download_failed)
        pub download_failed: ::protobuf::MessageField<error::DownloadFailed>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Error.conversion_failed)
        pub conversion_failed: ::protobuf::MessageField<error::ConversionFailed>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Error.unsupported_type)
        pub unsupported_type: ::protobuf::MessageField<error::UnsupportedType>,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.Subtitle.Error.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Error {
        fn default() -> &'a Error {
            <Error as ::protobuf::Message>::default_instance()
        }
    }

    impl Error {
        pub fn new() -> Error {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for Error {
        const NAME: &'static str = "Error";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = is.read_enum_or_unknown()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.invalid_url)?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.search_failed)?;
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.download_failed)?;
                    },
                    42 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.conversion_failed)?;
                    },
                    50 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.unsupported_type)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.type_ != ::protobuf::EnumOrUnknown::new(error::Type::INVALID_URL) {
                my_size += ::protobuf::rt::int32_size(1, self.type_.value());
            }
            if let Some(v) = self.invalid_url.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.search_failed.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.download_failed.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.conversion_failed.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.unsupported_type.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.type_ != ::protobuf::EnumOrUnknown::new(error::Type::INVALID_URL) {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
            }
            if let Some(v) = self.invalid_url.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.search_failed.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.download_failed.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            if let Some(v) = self.conversion_failed.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            if let Some(v) = self.unsupported_type.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Error {
            Error::new()
        }

        fn clear(&mut self) {
            self.type_ = ::protobuf::EnumOrUnknown::new(error::Type::INVALID_URL);
            self.invalid_url.clear();
            self.search_failed.clear();
            self.download_failed.clear();
            self.conversion_failed.clear();
            self.unsupported_type.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Error {
            static instance: Error = Error {
                type_: ::protobuf::EnumOrUnknown::from_i32(0),
                invalid_url: ::protobuf::MessageField::none(),
                search_failed: ::protobuf::MessageField::none(),
                download_failed: ::protobuf::MessageField::none(),
                conversion_failed: ::protobuf::MessageField::none(),
                unsupported_type: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Error`
    pub mod error {
        // @@protoc_insertion_point(message:fx.ipc.proto.Subtitle.Error.InvalidUrl)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct InvalidUrl {
            // message fields
            // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Error.InvalidUrl.url)
            pub url: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:fx.ipc.proto.Subtitle.Error.InvalidUrl.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a InvalidUrl {
            fn default() -> &'a InvalidUrl {
                <InvalidUrl as ::protobuf::Message>::default_instance()
            }
        }

        impl InvalidUrl {
            pub fn new() -> InvalidUrl {
                ::std::default::Default::default()
            }
        }

        impl ::protobuf::Message for InvalidUrl {
            const NAME: &'static str = "InvalidUrl";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.url = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.url.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.url);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.url.is_empty() {
                    os.write_string(1, &self.url)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> InvalidUrl {
                InvalidUrl::new()
            }

            fn clear(&mut self) {
                self.url.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static InvalidUrl {
                static instance: InvalidUrl = InvalidUrl {
                    url: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:fx.ipc.proto.Subtitle.Error.SearchFailed)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct SearchFailed {
            // message fields
            // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Error.SearchFailed.reason)
            pub reason: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:fx.ipc.proto.Subtitle.Error.SearchFailed.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a SearchFailed {
            fn default() -> &'a SearchFailed {
                <SearchFailed as ::protobuf::Message>::default_instance()
            }
        }

        impl SearchFailed {
            pub fn new() -> SearchFailed {
                ::std::default::Default::default()
            }
        }

        impl ::protobuf::Message for SearchFailed {
            const NAME: &'static str = "SearchFailed";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.reason = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.reason.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.reason);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.reason.is_empty() {
                    os.write_string(1, &self.reason)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> SearchFailed {
                SearchFailed::new()
            }

            fn clear(&mut self) {
                self.reason.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static SearchFailed {
                static instance: SearchFailed = SearchFailed {
                    reason: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:fx.ipc.proto.Subtitle.Error.DownloadFailed)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct DownloadFailed {
            // message fields
            // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Error.DownloadFailed.filename)
            pub filename: ::std::string::String,
            // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Error.DownloadFailed.reason)
            pub reason: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:fx.ipc.proto.Subtitle.Error.DownloadFailed.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a DownloadFailed {
            fn default() -> &'a DownloadFailed {
                <DownloadFailed as ::protobuf::Message>::default_instance()
            }
        }

        impl DownloadFailed {
            pub fn new() -> DownloadFailed {
                ::std::default::Default::default()
            }
        }

        impl ::protobuf::Message for DownloadFailed {
            const NAME: &'static str = "DownloadFailed";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.filename = is.read_string()?;
                        },
                        18 => {
                            self.reason = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.filename.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.filename);
                }
                if !self.reason.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.reason);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.filename.is_empty() {
                    os.write_string(1, &self.filename)?;
                }
                if !self.reason.is_empty() {
                    os.write_string(2, &self.reason)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> DownloadFailed {
                DownloadFailed::new()
            }

            fn clear(&mut self) {
                self.filename.clear();
                self.reason.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static DownloadFailed {
                static instance: DownloadFailed = DownloadFailed {
                    filename: ::std::string::String::new(),
                    reason: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:fx.ipc.proto.Subtitle.Error.ConversionFailed)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ConversionFailed {
            // message fields
            // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Error.ConversionFailed.type)
            pub type_: ::protobuf::EnumOrUnknown<super::Type>,
            // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Error.ConversionFailed.reason)
            pub reason: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:fx.ipc.proto.Subtitle.Error.ConversionFailed.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ConversionFailed {
            fn default() -> &'a ConversionFailed {
                <ConversionFailed as ::protobuf::Message>::default_instance()
            }
        }

        impl ConversionFailed {
            pub fn new() -> ConversionFailed {
                ::std::default::Default::default()
            }
        }

        impl ::protobuf::Message for ConversionFailed {
            const NAME: &'static str = "ConversionFailed";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.type_ = is.read_enum_or_unknown()?;
                        },
                        18 => {
                            self.reason = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.type_ != ::protobuf::EnumOrUnknown::new(super::Type::SRT) {
                    my_size += ::protobuf::rt::int32_size(1, self.type_.value());
                }
                if !self.reason.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.reason);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.type_ != ::protobuf::EnumOrUnknown::new(super::Type::SRT) {
                    os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
                }
                if !self.reason.is_empty() {
                    os.write_string(2, &self.reason)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ConversionFailed {
                ConversionFailed::new()
            }

            fn clear(&mut self) {
                self.type_ = ::protobuf::EnumOrUnknown::new(super::Type::SRT);
                self.reason.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ConversionFailed {
                static instance: ConversionFailed = ConversionFailed {
                    type_: ::protobuf::EnumOrUnknown::from_i32(0),
                    reason: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:fx.ipc.proto.Subtitle.Error.UnsupportedType)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct UnsupportedType {
            // message fields
            // @@protoc_insertion_point(field:fx.ipc.proto.Subtitle.Error.UnsupportedType.type)
            pub type_: ::protobuf::EnumOrUnknown<super::Type>,
            // special fields
            // @@protoc_insertion_point(special_field:fx.ipc.proto.Subtitle.Error.UnsupportedType.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a UnsupportedType {
            fn default() -> &'a UnsupportedType {
                <UnsupportedType as ::protobuf::Message>::default_instance()
            }
        }

        impl UnsupportedType {
            pub fn new() -> UnsupportedType {
                ::std::default::Default::default()
            }
        }

        impl ::protobuf::Message for UnsupportedType {
            const NAME: &'static str = "UnsupportedType";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.type_ = is.read_enum_or_unknown()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.type_ != ::protobuf::EnumOrUnknown::new(super::Type::SRT) {
                    my_size += ::protobuf::rt::int32_size(1, self.type_.value());
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.type_ != ::protobuf::EnumOrUnknown::new(super::Type::SRT) {
                    os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> UnsupportedType {
                UnsupportedType::new()
            }

            fn clear(&mut self) {
                self.type_ = ::protobuf::EnumOrUnknown::new(super::Type::SRT);
                self.special_fields.clear();
            }

            fn default_instance() -> &'static UnsupportedType {
                static instance: UnsupportedType = UnsupportedType {
                    type_: ::protobuf::EnumOrUnknown::from_i32(0),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:fx.ipc.proto.Subtitle.Error.Type)
        pub enum Type {
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Error.Type.INVALID_URL)
            INVALID_URL = 0,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Error.Type.SEARCH_FAILED)
            SEARCH_FAILED = 1,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Error.Type.DOWNLOAD_FAILED)
            DOWNLOAD_FAILED = 2,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Error.Type.IO)
            IO = 3,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Error.Type.PARSE_FILE)
            PARSE_FILE = 4,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Error.Type.PARSE_URL)
            PARSE_URL = 5,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Error.Type.CONVERSION)
            CONVERSION = 6,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Error.Type.UNSUPPORTED_TYPE)
            UNSUPPORTED_TYPE = 7,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Error.Type.NO_FILES_FOUND)
            NO_FILES_FOUND = 8,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Error.Type.INVALID_FILE)
            INVALID_FILE = 9,
        }

        impl ::protobuf::Enum for Type {
            const NAME: &'static str = "Type";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<Type> {
                match value {
                    0 => ::std::option::Option::Some(Type::INVALID_URL),
                    1 => ::std::option::Option::Some(Type::SEARCH_FAILED),
                    2 => ::std::option::Option::Some(Type::DOWNLOAD_FAILED),
                    3 => ::std::option::Option::Some(Type::IO),
                    4 => ::std::option::Option::Some(Type::PARSE_FILE),
                    5 => ::std::option::Option::Some(Type::PARSE_URL),
                    6 => ::std::option::Option::Some(Type::CONVERSION),
                    7 => ::std::option::Option::Some(Type::UNSUPPORTED_TYPE),
                    8 => ::std::option::Option::Some(Type::NO_FILES_FOUND),
                    9 => ::std::option::Option::Some(Type::INVALID_FILE),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<Type> {
                match str {
                    "INVALID_URL" => ::std::option::Option::Some(Type::INVALID_URL),
                    "SEARCH_FAILED" => ::std::option::Option::Some(Type::SEARCH_FAILED),
                    "DOWNLOAD_FAILED" => ::std::option::Option::Some(Type::DOWNLOAD_FAILED),
                    "IO" => ::std::option::Option::Some(Type::IO),
                    "PARSE_FILE" => ::std::option::Option::Some(Type::PARSE_FILE),
                    "PARSE_URL" => ::std::option::Option::Some(Type::PARSE_URL),
                    "CONVERSION" => ::std::option::Option::Some(Type::CONVERSION),
                    "UNSUPPORTED_TYPE" => ::std::option::Option::Some(Type::UNSUPPORTED_TYPE),
                    "NO_FILES_FOUND" => ::std::option::Option::Some(Type::NO_FILES_FOUND),
                    "INVALID_FILE" => ::std::option::Option::Some(Type::INVALID_FILE),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [Type] = &[
                Type::INVALID_URL,
                Type::SEARCH_FAILED,
                Type::DOWNLOAD_FAILED,
                Type::IO,
                Type::PARSE_FILE,
                Type::PARSE_URL,
                Type::CONVERSION,
                Type::UNSUPPORTED_TYPE,
                Type::NO_FILES_FOUND,
                Type::INVALID_FILE,
            ];
        }

        impl ::std::default::Default for Type {
            fn default() -> Self {
                Type::INVALID_URL
            }
        }

    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:fx.ipc.proto.Subtitle.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Type.SRT)
        SRT = 0,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Type.VTT)
        VTT = 1,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                0 => ::std::option::Option::Some(Type::SRT),
                1 => ::std::option::Option::Some(Type::VTT),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Type> {
            match str {
                "SRT" => ::std::option::Option::Some(Type::SRT),
                "VTT" => ::std::option::Option::Some(Type::VTT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::SRT,
            Type::VTT,
        ];
    }

    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::SRT
        }
    }


    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:fx.ipc.proto.Subtitle.Language)
    pub enum Language {
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.NONE)
        NONE = 0,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.CUSTOM)
        CUSTOM = 1,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.ARABIC)
        ARABIC = 2,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.BULGARIAN)
        BULGARIAN = 3,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.BOSNIAN)
        BOSNIAN = 4,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.CZECH)
        CZECH = 5,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.DANISH)
        DANISH = 6,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.GERMAN)
        GERMAN = 7,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.MODERN_GREEK)
        MODERN_GREEK = 8,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.ENGLISH)
        ENGLISH = 9,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.SPANISH)
        SPANISH = 10,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.ESTONIAN)
        ESTONIAN = 11,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.BASQUE)
        BASQUE = 12,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.PERSIAN)
        PERSIAN = 13,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.FINNISH)
        FINNISH = 14,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.FRENCH)
        FRENCH = 15,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.HEBREW)
        HEBREW = 16,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.CROATIAN)
        CROATIAN = 17,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.HUNGARIAN)
        HUNGARIAN = 18,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.INDONESIAN)
        INDONESIAN = 19,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.ITALIAN)
        ITALIAN = 20,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.LITHUANIAN)
        LITHUANIAN = 21,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.DUTCH)
        DUTCH = 22,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.NORWEGIAN)
        NORWEGIAN = 23,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.POLISH)
        POLISH = 24,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.PORTUGUESE)
        PORTUGUESE = 25,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.PORTUGUESE_BRAZIL)
        PORTUGUESE_BRAZIL = 26,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.ROMANIAN)
        ROMANIAN = 27,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.RUSSIAN)
        RUSSIAN = 28,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.SLOVENE)
        SLOVENE = 29,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.SERBIAN)
        SERBIAN = 30,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.SWEDISH)
        SWEDISH = 31,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.THAI)
        THAI = 32,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.TURKISH)
        TURKISH = 33,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.UKRAINIAN)
        UKRAINIAN = 34,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Subtitle.Language.VIETNAMESE)
        VIETNAMESE = 35,
    }

    impl ::protobuf::Enum for Language {
        const NAME: &'static str = "Language";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Language> {
            match value {
                0 => ::std::option::Option::Some(Language::NONE),
                1 => ::std::option::Option::Some(Language::CUSTOM),
                2 => ::std::option::Option::Some(Language::ARABIC),
                3 => ::std::option::Option::Some(Language::BULGARIAN),
                4 => ::std::option::Option::Some(Language::BOSNIAN),
                5 => ::std::option::Option::Some(Language::CZECH),
                6 => ::std::option::Option::Some(Language::DANISH),
                7 => ::std::option::Option::Some(Language::GERMAN),
                8 => ::std::option::Option::Some(Language::MODERN_GREEK),
                9 => ::std::option::Option::Some(Language::ENGLISH),
                10 => ::std::option::Option::Some(Language::SPANISH),
                11 => ::std::option::Option::Some(Language::ESTONIAN),
                12 => ::std::option::Option::Some(Language::BASQUE),
                13 => ::std::option::Option::Some(Language::PERSIAN),
                14 => ::std::option::Option::Some(Language::FINNISH),
                15 => ::std::option::Option::Some(Language::FRENCH),
                16 => ::std::option::Option::Some(Language::HEBREW),
                17 => ::std::option::Option::Some(Language::CROATIAN),
                18 => ::std::option::Option::Some(Language::HUNGARIAN),
                19 => ::std::option::Option::Some(Language::INDONESIAN),
                20 => ::std::option::Option::Some(Language::ITALIAN),
                21 => ::std::option::Option::Some(Language::LITHUANIAN),
                22 => ::std::option::Option::Some(Language::DUTCH),
                23 => ::std::option::Option::Some(Language::NORWEGIAN),
                24 => ::std::option::Option::Some(Language::POLISH),
                25 => ::std::option::Option::Some(Language::PORTUGUESE),
                26 => ::std::option::Option::Some(Language::PORTUGUESE_BRAZIL),
                27 => ::std::option::Option::Some(Language::ROMANIAN),
                28 => ::std::option::Option::Some(Language::RUSSIAN),
                29 => ::std::option::Option::Some(Language::SLOVENE),
                30 => ::std::option::Option::Some(Language::SERBIAN),
                31 => ::std::option::Option::Some(Language::SWEDISH),
                32 => ::std::option::Option::Some(Language::THAI),
                33 => ::std::option::Option::Some(Language::TURKISH),
                34 => ::std::option::Option::Some(Language::UKRAINIAN),
                35 => ::std::option::Option::Some(Language::VIETNAMESE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Language> {
            match str {
                "NONE" => ::std::option::Option::Some(Language::NONE),
                "CUSTOM" => ::std::option::Option::Some(Language::CUSTOM),
                "ARABIC" => ::std::option::Option::Some(Language::ARABIC),
                "BULGARIAN" => ::std::option::Option::Some(Language::BULGARIAN),
                "BOSNIAN" => ::std::option::Option::Some(Language::BOSNIAN),
                "CZECH" => ::std::option::Option::Some(Language::CZECH),
                "DANISH" => ::std::option::Option::Some(Language::DANISH),
                "GERMAN" => ::std::option::Option::Some(Language::GERMAN),
                "MODERN_GREEK" => ::std::option::Option::Some(Language::MODERN_GREEK),
                "ENGLISH" => ::std::option::Option::Some(Language::ENGLISH),
                "SPANISH" => ::std::option::Option::Some(Language::SPANISH),
                "ESTONIAN" => ::std::option::Option::Some(Language::ESTONIAN),
                "BASQUE" => ::std::option::Option::Some(Language::BASQUE),
                "PERSIAN" => ::std::option::Option::Some(Language::PERSIAN),
                "FINNISH" => ::std::option::Option::Some(Language::FINNISH),
                "FRENCH" => ::std::option::Option::Some(Language::FRENCH),
                "HEBREW" => ::std::option::Option::Some(Language::HEBREW),
                "CROATIAN" => ::std::option::Option::Some(Language::CROATIAN),
                "HUNGARIAN" => ::std::option::Option::Some(Language::HUNGARIAN),
                "INDONESIAN" => ::std::option::Option::Some(Language::INDONESIAN),
                "ITALIAN" => ::std::option::Option::Some(Language::ITALIAN),
                "LITHUANIAN" => ::std::option::Option::Some(Language::LITHUANIAN),
                "DUTCH" => ::std::option::Option::Some(Language::DUTCH),
                "NORWEGIAN" => ::std::option::Option::Some(Language::NORWEGIAN),
                "POLISH" => ::std::option::Option::Some(Language::POLISH),
                "PORTUGUESE" => ::std::option::Option::Some(Language::PORTUGUESE),
                "PORTUGUESE_BRAZIL" => ::std::option::Option::Some(Language::PORTUGUESE_BRAZIL),
                "ROMANIAN" => ::std::option::Option::Some(Language::ROMANIAN),
                "RUSSIAN" => ::std::option::Option::Some(Language::RUSSIAN),
                "SLOVENE" => ::std::option::Option::Some(Language::SLOVENE),
                "SERBIAN" => ::std::option::Option::Some(Language::SERBIAN),
                "SWEDISH" => ::std::option::Option::Some(Language::SWEDISH),
                "THAI" => ::std::option::Option::Some(Language::THAI),
                "TURKISH" => ::std::option::Option::Some(Language::TURKISH),
                "UKRAINIAN" => ::std::option::Option::Some(Language::UKRAINIAN),
                "VIETNAMESE" => ::std::option::Option::Some(Language::VIETNAMESE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Language] = &[
            Language::NONE,
            Language::CUSTOM,
            Language::ARABIC,
            Language::BULGARIAN,
            Language::BOSNIAN,
            Language::CZECH,
            Language::DANISH,
            Language::GERMAN,
            Language::MODERN_GREEK,
            Language::ENGLISH,
            Language::SPANISH,
            Language::ESTONIAN,
            Language::BASQUE,
            Language::PERSIAN,
            Language::FINNISH,
            Language::FRENCH,
            Language::HEBREW,
            Language::CROATIAN,
            Language::HUNGARIAN,
            Language::INDONESIAN,
            Language::ITALIAN,
            Language::LITHUANIAN,
            Language::DUTCH,
            Language::NORWEGIAN,
            Language::POLISH,
            Language::PORTUGUESE,
            Language::PORTUGUESE_BRAZIL,
            Language::ROMANIAN,
            Language::RUSSIAN,
            Language::SLOVENE,
            Language::SERBIAN,
            Language::SWEDISH,
            Language::THAI,
            Language::TURKISH,
            Language::UKRAINIAN,
            Language::VIETNAMESE,
        ];
    }

    impl ::std::default::Default for Language {
        fn default() -> Self {
            Language::NONE
        }
    }

}

// @@protoc_insertion_point(message:fx.ipc.proto.SubtitleEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubtitleEvent {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.SubtitleEvent.event)
    pub event: ::protobuf::EnumOrUnknown<subtitle_event::Event>,
    // @@protoc_insertion_point(field:fx.ipc.proto.SubtitleEvent.preference_changed)
    pub preference_changed: ::protobuf::MessageField<subtitle_event::PreferenceChanged>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.SubtitleEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubtitleEvent {
    fn default() -> &'a SubtitleEvent {
        <SubtitleEvent as ::protobuf::Message>::default_instance()
    }
}

impl SubtitleEvent {
    pub fn new() -> SubtitleEvent {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubtitleEvent {
    const NAME: &'static str = "SubtitleEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.preference_changed)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.event != ::protobuf::EnumOrUnknown::new(subtitle_event::Event::PREFERENCE_CHANGED) {
            my_size += ::protobuf::rt::int32_size(1, self.event.value());
        }
        if let Some(v) = self.preference_changed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.event != ::protobuf::EnumOrUnknown::new(subtitle_event::Event::PREFERENCE_CHANGED) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.event))?;
        }
        if let Some(v) = self.preference_changed.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubtitleEvent {
        SubtitleEvent::new()
    }

    fn clear(&mut self) {
        self.event = ::protobuf::EnumOrUnknown::new(subtitle_event::Event::PREFERENCE_CHANGED);
        self.preference_changed.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubtitleEvent {
        static instance: SubtitleEvent = SubtitleEvent {
            event: ::protobuf::EnumOrUnknown::from_i32(0),
            preference_changed: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `SubtitleEvent`
pub mod subtitle_event {
    // @@protoc_insertion_point(message:fx.ipc.proto.SubtitleEvent.PreferenceChanged)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PreferenceChanged {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.SubtitleEvent.PreferenceChanged.preference)
        pub preference: ::protobuf::MessageField<super::SubtitlePreference>,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.SubtitleEvent.PreferenceChanged.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PreferenceChanged {
        fn default() -> &'a PreferenceChanged {
            <PreferenceChanged as ::protobuf::Message>::default_instance()
        }
    }

    impl PreferenceChanged {
        pub fn new() -> PreferenceChanged {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for PreferenceChanged {
        const NAME: &'static str = "PreferenceChanged";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.preference)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.preference.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.preference.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PreferenceChanged {
            PreferenceChanged::new()
        }

        fn clear(&mut self) {
            self.preference.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PreferenceChanged {
            static instance: PreferenceChanged = PreferenceChanged {
                preference: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:fx.ipc.proto.SubtitleEvent.Event)
    pub enum Event {
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.SubtitleEvent.Event.PREFERENCE_CHANGED)
        PREFERENCE_CHANGED = 0,
    }

    impl ::protobuf::Enum for Event {
        const NAME: &'static str = "Event";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Event> {
            match value {
                0 => ::std::option::Option::Some(Event::PREFERENCE_CHANGED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Event> {
            match str {
                "PREFERENCE_CHANGED" => ::std::option::Option::Some(Event::PREFERENCE_CHANGED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Event] = &[
            Event::PREFERENCE_CHANGED,
        ];
    }

    impl ::std::default::Default for Event {
        fn default() -> Self {
            Event::PREFERENCE_CHANGED
        }
    }

}

// @@protoc_insertion_point(message:fx.ipc.proto.GetSubtitlePreferenceRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetSubtitlePreferenceRequest {
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.GetSubtitlePreferenceRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSubtitlePreferenceRequest {
    fn default() -> &'a GetSubtitlePreferenceRequest {
        <GetSubtitlePreferenceRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSubtitlePreferenceRequest {
    pub fn new() -> GetSubtitlePreferenceRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetSubtitlePreferenceRequest {
    const NAME: &'static str = "GetSubtitlePreferenceRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSubtitlePreferenceRequest {
        GetSubtitlePreferenceRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSubtitlePreferenceRequest {
        static instance: GetSubtitlePreferenceRequest = GetSubtitlePreferenceRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.GetSubtitlePreferenceResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetSubtitlePreferenceResponse {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.GetSubtitlePreferenceResponse.preference)
    pub preference: ::protobuf::MessageField<SubtitlePreference>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.GetSubtitlePreferenceResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSubtitlePreferenceResponse {
    fn default() -> &'a GetSubtitlePreferenceResponse {
        <GetSubtitlePreferenceResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetSubtitlePreferenceResponse {
    pub fn new() -> GetSubtitlePreferenceResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetSubtitlePreferenceResponse {
    const NAME: &'static str = "GetSubtitlePreferenceResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.preference)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.preference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.preference.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSubtitlePreferenceResponse {
        GetSubtitlePreferenceResponse::new()
    }

    fn clear(&mut self) {
        self.preference.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSubtitlePreferenceResponse {
        static instance: GetSubtitlePreferenceResponse = GetSubtitlePreferenceResponse {
            preference: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.UpdateSubtitlePreferenceRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpdateSubtitlePreferenceRequest {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.UpdateSubtitlePreferenceRequest.preference)
    pub preference: ::protobuf::MessageField<SubtitlePreference>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.UpdateSubtitlePreferenceRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateSubtitlePreferenceRequest {
    fn default() -> &'a UpdateSubtitlePreferenceRequest {
        <UpdateSubtitlePreferenceRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateSubtitlePreferenceRequest {
    pub fn new() -> UpdateSubtitlePreferenceRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdateSubtitlePreferenceRequest {
    const NAME: &'static str = "UpdateSubtitlePreferenceRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.preference)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.preference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.preference.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateSubtitlePreferenceRequest {
        UpdateSubtitlePreferenceRequest::new()
    }

    fn clear(&mut self) {
        self.preference.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateSubtitlePreferenceRequest {
        static instance: UpdateSubtitlePreferenceRequest = UpdateSubtitlePreferenceRequest {
            preference: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.GetDefaultSubtitlesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetDefaultSubtitlesRequest {
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.GetDefaultSubtitlesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetDefaultSubtitlesRequest {
    fn default() -> &'a GetDefaultSubtitlesRequest {
        <GetDefaultSubtitlesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDefaultSubtitlesRequest {
    pub fn new() -> GetDefaultSubtitlesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetDefaultSubtitlesRequest {
    const NAME: &'static str = "GetDefaultSubtitlesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetDefaultSubtitlesRequest {
        GetDefaultSubtitlesRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetDefaultSubtitlesRequest {
        static instance: GetDefaultSubtitlesRequest = GetDefaultSubtitlesRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.GetDefaultSubtitlesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetDefaultSubtitlesResponse {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.GetDefaultSubtitlesResponse.subtitles)
    pub subtitles: ::std::vec::Vec<subtitle::Info>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.GetDefaultSubtitlesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetDefaultSubtitlesResponse {
    fn default() -> &'a GetDefaultSubtitlesResponse {
        <GetDefaultSubtitlesResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetDefaultSubtitlesResponse {
    pub fn new() -> GetDefaultSubtitlesResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetDefaultSubtitlesResponse {
    const NAME: &'static str = "GetDefaultSubtitlesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.subtitles.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.subtitles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.subtitles {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetDefaultSubtitlesResponse {
        GetDefaultSubtitlesResponse::new()
    }

    fn clear(&mut self) {
        self.subtitles.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetDefaultSubtitlesResponse {
        static instance: GetDefaultSubtitlesResponse = GetDefaultSubtitlesResponse {
            subtitles: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.GetMediaAvailableSubtitlesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetMediaAvailableSubtitlesRequest {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.GetMediaAvailableSubtitlesRequest.item)
    pub item: ::protobuf::MessageField<super::media::media::Item>,
    // @@protoc_insertion_point(field:fx.ipc.proto.GetMediaAvailableSubtitlesRequest.sub_item)
    pub sub_item: ::protobuf::MessageField<super::media::media::Item>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.GetMediaAvailableSubtitlesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetMediaAvailableSubtitlesRequest {
    fn default() -> &'a GetMediaAvailableSubtitlesRequest {
        <GetMediaAvailableSubtitlesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetMediaAvailableSubtitlesRequest {
    pub fn new() -> GetMediaAvailableSubtitlesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetMediaAvailableSubtitlesRequest {
    const NAME: &'static str = "GetMediaAvailableSubtitlesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.item)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sub_item)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.sub_item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.sub_item.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetMediaAvailableSubtitlesRequest {
        GetMediaAvailableSubtitlesRequest::new()
    }

    fn clear(&mut self) {
        self.item.clear();
        self.sub_item.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetMediaAvailableSubtitlesRequest {
        static instance: GetMediaAvailableSubtitlesRequest = GetMediaAvailableSubtitlesRequest {
            item: ::protobuf::MessageField::none(),
            sub_item: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.GetMediaAvailableSubtitlesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetMediaAvailableSubtitlesResponse {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.GetMediaAvailableSubtitlesResponse.result)
    pub result: ::protobuf::EnumOrUnknown<super::message::response::Result>,
    // @@protoc_insertion_point(field:fx.ipc.proto.GetMediaAvailableSubtitlesResponse.subtitles)
    pub subtitles: ::std::vec::Vec<subtitle::Info>,
    // @@protoc_insertion_point(field:fx.ipc.proto.GetMediaAvailableSubtitlesResponse.error)
    pub error: ::protobuf::MessageField<subtitle::Error>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.GetMediaAvailableSubtitlesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetMediaAvailableSubtitlesResponse {
    fn default() -> &'a GetMediaAvailableSubtitlesResponse {
        <GetMediaAvailableSubtitlesResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetMediaAvailableSubtitlesResponse {
    pub fn new() -> GetMediaAvailableSubtitlesResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetMediaAvailableSubtitlesResponse {
    const NAME: &'static str = "GetMediaAvailableSubtitlesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.subtitles.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.result != ::protobuf::EnumOrUnknown::new(super::message::response::Result::OK) {
            my_size += ::protobuf::rt::int32_size(1, self.result.value());
        }
        for value in &self.subtitles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.result != ::protobuf::EnumOrUnknown::new(super::message::response::Result::OK) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.result))?;
        }
        for v in &self.subtitles {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetMediaAvailableSubtitlesResponse {
        GetMediaAvailableSubtitlesResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::protobuf::EnumOrUnknown::new(super::message::response::Result::OK);
        self.subtitles.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetMediaAvailableSubtitlesResponse {
        static instance: GetMediaAvailableSubtitlesResponse = GetMediaAvailableSubtitlesResponse {
            result: ::protobuf::EnumOrUnknown::from_i32(0),
            subtitles: ::std::vec::Vec::new(),
            error: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.GetFileAvailableSubtitlesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetFileAvailableSubtitlesRequest {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.GetFileAvailableSubtitlesRequest.filename)
    pub filename: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.GetFileAvailableSubtitlesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetFileAvailableSubtitlesRequest {
    fn default() -> &'a GetFileAvailableSubtitlesRequest {
        <GetFileAvailableSubtitlesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetFileAvailableSubtitlesRequest {
    pub fn new() -> GetFileAvailableSubtitlesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetFileAvailableSubtitlesRequest {
    const NAME: &'static str = "GetFileAvailableSubtitlesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.filename = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.filename.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.filename);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.filename.is_empty() {
            os.write_string(1, &self.filename)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetFileAvailableSubtitlesRequest {
        GetFileAvailableSubtitlesRequest::new()
    }

    fn clear(&mut self) {
        self.filename.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetFileAvailableSubtitlesRequest {
        static instance: GetFileAvailableSubtitlesRequest = GetFileAvailableSubtitlesRequest {
            filename: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.GetFileAvailableSubtitlesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetFileAvailableSubtitlesResponse {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.GetFileAvailableSubtitlesResponse.result)
    pub result: ::protobuf::EnumOrUnknown<super::message::response::Result>,
    // @@protoc_insertion_point(field:fx.ipc.proto.GetFileAvailableSubtitlesResponse.subtitles)
    pub subtitles: ::std::vec::Vec<subtitle::Info>,
    // @@protoc_insertion_point(field:fx.ipc.proto.GetFileAvailableSubtitlesResponse.error)
    pub error: ::protobuf::MessageField<subtitle::Error>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.GetFileAvailableSubtitlesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetFileAvailableSubtitlesResponse {
    fn default() -> &'a GetFileAvailableSubtitlesResponse {
        <GetFileAvailableSubtitlesResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetFileAvailableSubtitlesResponse {
    pub fn new() -> GetFileAvailableSubtitlesResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetFileAvailableSubtitlesResponse {
    const NAME: &'static str = "GetFileAvailableSubtitlesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.subtitles.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.result != ::protobuf::EnumOrUnknown::new(super::message::response::Result::OK) {
            my_size += ::protobuf::rt::int32_size(1, self.result.value());
        }
        for value in &self.subtitles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.result != ::protobuf::EnumOrUnknown::new(super::message::response::Result::OK) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.result))?;
        }
        for v in &self.subtitles {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetFileAvailableSubtitlesResponse {
        GetFileAvailableSubtitlesResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::protobuf::EnumOrUnknown::new(super::message::response::Result::OK);
        self.subtitles.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetFileAvailableSubtitlesResponse {
        static instance: GetFileAvailableSubtitlesResponse = GetFileAvailableSubtitlesResponse {
            result: ::protobuf::EnumOrUnknown::from_i32(0),
            subtitles: ::std::vec::Vec::new(),
            error: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.GetPreferredSubtitleRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetPreferredSubtitleRequest {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.GetPreferredSubtitleRequest.subtitles)
    pub subtitles: ::std::vec::Vec<subtitle::Info>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.GetPreferredSubtitleRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetPreferredSubtitleRequest {
    fn default() -> &'a GetPreferredSubtitleRequest {
        <GetPreferredSubtitleRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetPreferredSubtitleRequest {
    pub fn new() -> GetPreferredSubtitleRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetPreferredSubtitleRequest {
    const NAME: &'static str = "GetPreferredSubtitleRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.subtitles.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.subtitles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.subtitles {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetPreferredSubtitleRequest {
        GetPreferredSubtitleRequest::new()
    }

    fn clear(&mut self) {
        self.subtitles.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetPreferredSubtitleRequest {
        static instance: GetPreferredSubtitleRequest = GetPreferredSubtitleRequest {
            subtitles: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.GetPreferredSubtitleResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetPreferredSubtitleResponse {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.GetPreferredSubtitleResponse.subtitle)
    pub subtitle: ::protobuf::MessageField<subtitle::Info>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.GetPreferredSubtitleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetPreferredSubtitleResponse {
    fn default() -> &'a GetPreferredSubtitleResponse {
        <GetPreferredSubtitleResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetPreferredSubtitleResponse {
    pub fn new() -> GetPreferredSubtitleResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetPreferredSubtitleResponse {
    const NAME: &'static str = "GetPreferredSubtitleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.subtitle)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.subtitle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.subtitle.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetPreferredSubtitleResponse {
        GetPreferredSubtitleResponse::new()
    }

    fn clear(&mut self) {
        self.subtitle.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetPreferredSubtitleResponse {
        static instance: GetPreferredSubtitleResponse = GetPreferredSubtitleResponse {
            subtitle: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.ResetSubtitleRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResetSubtitleRequest {
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.ResetSubtitleRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResetSubtitleRequest {
    fn default() -> &'a ResetSubtitleRequest {
        <ResetSubtitleRequest as ::protobuf::Message>::default_instance()
    }
}

impl ResetSubtitleRequest {
    pub fn new() -> ResetSubtitleRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ResetSubtitleRequest {
    const NAME: &'static str = "ResetSubtitleRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResetSubtitleRequest {
        ResetSubtitleRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResetSubtitleRequest {
        static instance: ResetSubtitleRequest = ResetSubtitleRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.CleanSubtitlesDirectoryRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CleanSubtitlesDirectoryRequest {
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.CleanSubtitlesDirectoryRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CleanSubtitlesDirectoryRequest {
    fn default() -> &'a CleanSubtitlesDirectoryRequest {
        <CleanSubtitlesDirectoryRequest as ::protobuf::Message>::default_instance()
    }
}

impl CleanSubtitlesDirectoryRequest {
    pub fn new() -> CleanSubtitlesDirectoryRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CleanSubtitlesDirectoryRequest {
    const NAME: &'static str = "CleanSubtitlesDirectoryRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CleanSubtitlesDirectoryRequest {
        CleanSubtitlesDirectoryRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CleanSubtitlesDirectoryRequest {
        static instance: CleanSubtitlesDirectoryRequest = CleanSubtitlesDirectoryRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.DownloadAndParseSubtitleRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DownloadAndParseSubtitleRequest {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.DownloadAndParseSubtitleRequest.info)
    pub info: ::protobuf::MessageField<subtitle::Info>,
    // @@protoc_insertion_point(field:fx.ipc.proto.DownloadAndParseSubtitleRequest.matcher)
    pub matcher: ::protobuf::MessageField<subtitle::Matcher>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.DownloadAndParseSubtitleRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DownloadAndParseSubtitleRequest {
    fn default() -> &'a DownloadAndParseSubtitleRequest {
        <DownloadAndParseSubtitleRequest as ::protobuf::Message>::default_instance()
    }
}

impl DownloadAndParseSubtitleRequest {
    pub fn new() -> DownloadAndParseSubtitleRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DownloadAndParseSubtitleRequest {
    const NAME: &'static str = "DownloadAndParseSubtitleRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.matcher)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.matcher.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.matcher.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DownloadAndParseSubtitleRequest {
        DownloadAndParseSubtitleRequest::new()
    }

    fn clear(&mut self) {
        self.info.clear();
        self.matcher.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DownloadAndParseSubtitleRequest {
        static instance: DownloadAndParseSubtitleRequest = DownloadAndParseSubtitleRequest {
            info: ::protobuf::MessageField::none(),
            matcher: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.DownloadAndParseSubtitleResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DownloadAndParseSubtitleResponse {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.DownloadAndParseSubtitleResponse.result)
    pub result: ::protobuf::EnumOrUnknown<super::message::response::Result>,
    // @@protoc_insertion_point(field:fx.ipc.proto.DownloadAndParseSubtitleResponse.subtitle)
    pub subtitle: ::protobuf::MessageField<Subtitle>,
    // @@protoc_insertion_point(field:fx.ipc.proto.DownloadAndParseSubtitleResponse.error)
    pub error: ::protobuf::MessageField<subtitle::Error>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.DownloadAndParseSubtitleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DownloadAndParseSubtitleResponse {
    fn default() -> &'a DownloadAndParseSubtitleResponse {
        <DownloadAndParseSubtitleResponse as ::protobuf::Message>::default_instance()
    }
}

impl DownloadAndParseSubtitleResponse {
    pub fn new() -> DownloadAndParseSubtitleResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DownloadAndParseSubtitleResponse {
    const NAME: &'static str = "DownloadAndParseSubtitleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.subtitle)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.result != ::protobuf::EnumOrUnknown::new(super::message::response::Result::OK) {
            my_size += ::protobuf::rt::int32_size(1, self.result.value());
        }
        if let Some(v) = self.subtitle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.result != ::protobuf::EnumOrUnknown::new(super::message::response::Result::OK) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.result))?;
        }
        if let Some(v) = self.subtitle.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DownloadAndParseSubtitleResponse {
        DownloadAndParseSubtitleResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::protobuf::EnumOrUnknown::new(super::message::response::Result::OK);
        self.subtitle.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DownloadAndParseSubtitleResponse {
        static instance: DownloadAndParseSubtitleResponse = DownloadAndParseSubtitleResponse {
            result: ::protobuf::EnumOrUnknown::from_i32(0),
            subtitle: ::protobuf::MessageField::none(),
            error: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}
