// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by protoc 29.3
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `loader.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

// @@protoc_insertion_point(message:fx.ipc.proto.Loading)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Loading {
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.Loading.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Loading {
    fn default() -> &'a Loading {
        <Loading as ::protobuf::Message>::default_instance()
    }
}

impl Loading {
    pub fn new() -> Loading {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Loading {
    const NAME: &'static str = "Loading";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Loading {
        Loading::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Loading {
        static instance: Loading = Loading {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `Loading`
pub mod loading {
    // @@protoc_insertion_point(message:fx.ipc.proto.Loading.Progress)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Progress {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.Loading.Progress.progress)
        pub progress: f32,
        // @@protoc_insertion_point(field:fx.ipc.proto.Loading.Progress.seeds)
        pub seeds: u32,
        // @@protoc_insertion_point(field:fx.ipc.proto.Loading.Progress.peers)
        pub peers: u32,
        // @@protoc_insertion_point(field:fx.ipc.proto.Loading.Progress.download_speed)
        pub download_speed: u64,
        // @@protoc_insertion_point(field:fx.ipc.proto.Loading.Progress.upload_speed)
        pub upload_speed: u64,
        // @@protoc_insertion_point(field:fx.ipc.proto.Loading.Progress.downloaded)
        pub downloaded: u64,
        // @@protoc_insertion_point(field:fx.ipc.proto.Loading.Progress.total_size)
        pub total_size: u64,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.Loading.Progress.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Progress {
        fn default() -> &'a Progress {
            <Progress as ::protobuf::Message>::default_instance()
        }
    }

    impl Progress {
        pub fn new() -> Progress {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for Progress {
        const NAME: &'static str = "Progress";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.progress = is.read_float()?;
                    },
                    16 => {
                        self.seeds = is.read_uint32()?;
                    },
                    24 => {
                        self.peers = is.read_uint32()?;
                    },
                    32 => {
                        self.download_speed = is.read_uint64()?;
                    },
                    40 => {
                        self.upload_speed = is.read_uint64()?;
                    },
                    48 => {
                        self.downloaded = is.read_uint64()?;
                    },
                    56 => {
                        self.total_size = is.read_uint64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.progress != 0. {
                my_size += 1 + 4;
            }
            if self.seeds != 0 {
                my_size += ::protobuf::rt::uint32_size(2, self.seeds);
            }
            if self.peers != 0 {
                my_size += ::protobuf::rt::uint32_size(3, self.peers);
            }
            if self.download_speed != 0 {
                my_size += ::protobuf::rt::uint64_size(4, self.download_speed);
            }
            if self.upload_speed != 0 {
                my_size += ::protobuf::rt::uint64_size(5, self.upload_speed);
            }
            if self.downloaded != 0 {
                my_size += ::protobuf::rt::uint64_size(6, self.downloaded);
            }
            if self.total_size != 0 {
                my_size += ::protobuf::rt::uint64_size(7, self.total_size);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.progress != 0. {
                os.write_float(1, self.progress)?;
            }
            if self.seeds != 0 {
                os.write_uint32(2, self.seeds)?;
            }
            if self.peers != 0 {
                os.write_uint32(3, self.peers)?;
            }
            if self.download_speed != 0 {
                os.write_uint64(4, self.download_speed)?;
            }
            if self.upload_speed != 0 {
                os.write_uint64(5, self.upload_speed)?;
            }
            if self.downloaded != 0 {
                os.write_uint64(6, self.downloaded)?;
            }
            if self.total_size != 0 {
                os.write_uint64(7, self.total_size)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Progress {
            Progress::new()
        }

        fn clear(&mut self) {
            self.progress = 0.;
            self.seeds = 0;
            self.peers = 0;
            self.download_speed = 0;
            self.upload_speed = 0;
            self.downloaded = 0;
            self.total_size = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Progress {
            static instance: Progress = Progress {
                progress: 0.,
                seeds: 0,
                peers: 0,
                download_speed: 0,
                upload_speed: 0,
                downloaded: 0,
                total_size: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:fx.ipc.proto.Loading.Error)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Error {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.Loading.Error.type)
        pub type_: ::protobuf::EnumOrUnknown<error::Type>,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.Loading.Error.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Error {
        fn default() -> &'a Error {
            <Error as ::protobuf::Message>::default_instance()
        }
    }

    impl Error {
        pub fn new() -> Error {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for Error {
        const NAME: &'static str = "Error";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = is.read_enum_or_unknown()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.type_ != ::protobuf::EnumOrUnknown::new(error::Type::PARSE) {
                my_size += ::protobuf::rt::int32_size(1, self.type_.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.type_ != ::protobuf::EnumOrUnknown::new(error::Type::PARSE) {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Error {
            Error::new()
        }

        fn clear(&mut self) {
            self.type_ = ::protobuf::EnumOrUnknown::new(error::Type::PARSE);
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Error {
            static instance: Error = Error {
                type_: ::protobuf::EnumOrUnknown::from_i32(0),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Error`
    pub mod error {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:fx.ipc.proto.Loading.Error.Type)
        pub enum Type {
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Loading.Error.Type.PARSE)
            PARSE = 0,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Loading.Error.Type.TORRENT)
            TORRENT = 1,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Loading.Error.Type.MEDIA)
            MEDIA = 2,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Loading.Error.Type.TIMEOUT)
            TIMEOUT = 3,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Loading.Error.Type.INVALID_DATA)
            INVALID_DATA = 4,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Loading.Error.Type.CANCELLED)
            CANCELLED = 5,
        }

        impl ::protobuf::Enum for Type {
            const NAME: &'static str = "Type";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<Type> {
                match value {
                    0 => ::std::option::Option::Some(Type::PARSE),
                    1 => ::std::option::Option::Some(Type::TORRENT),
                    2 => ::std::option::Option::Some(Type::MEDIA),
                    3 => ::std::option::Option::Some(Type::TIMEOUT),
                    4 => ::std::option::Option::Some(Type::INVALID_DATA),
                    5 => ::std::option::Option::Some(Type::CANCELLED),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<Type> {
                match str {
                    "PARSE" => ::std::option::Option::Some(Type::PARSE),
                    "TORRENT" => ::std::option::Option::Some(Type::TORRENT),
                    "MEDIA" => ::std::option::Option::Some(Type::MEDIA),
                    "TIMEOUT" => ::std::option::Option::Some(Type::TIMEOUT),
                    "INVALID_DATA" => ::std::option::Option::Some(Type::INVALID_DATA),
                    "CANCELLED" => ::std::option::Option::Some(Type::CANCELLED),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [Type] = &[
                Type::PARSE,
                Type::TORRENT,
                Type::MEDIA,
                Type::TIMEOUT,
                Type::INVALID_DATA,
                Type::CANCELLED,
            ];
        }

        impl ::std::default::Default for Type {
            fn default() -> Self {
                Type::PARSE
            }
        }

    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:fx.ipc.proto.Loading.State)
    pub enum State {
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Loading.State.INITIALIZING)
        INITIALIZING = 0,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Loading.State.STARTING)
        STARTING = 1,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Loading.State.RETRIEVING_SUBTITLES)
        RETRIEVING_SUBTITLES = 2,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Loading.State.DOWNLOADING_SUBTITLE)
        DOWNLOADING_SUBTITLE = 3,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Loading.State.RETRIEVING_METADATA)
        RETRIEVING_METADATA = 4,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Loading.State.VERIFYING_FILES)
        VERIFYING_FILES = 5,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Loading.State.CONNECTING)
        CONNECTING = 6,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Loading.State.DOWNLOADING)
        DOWNLOADING = 7,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Loading.State.DOWNLOAD_FINISHED)
        DOWNLOAD_FINISHED = 8,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Loading.State.READY)
        READY = 9,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Loading.State.PLAYING)
        PLAYING = 10,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Loading.State.CANCELLED)
        CANCELLED = 11,
    }

    impl ::protobuf::Enum for State {
        const NAME: &'static str = "State";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<State> {
            match value {
                0 => ::std::option::Option::Some(State::INITIALIZING),
                1 => ::std::option::Option::Some(State::STARTING),
                2 => ::std::option::Option::Some(State::RETRIEVING_SUBTITLES),
                3 => ::std::option::Option::Some(State::DOWNLOADING_SUBTITLE),
                4 => ::std::option::Option::Some(State::RETRIEVING_METADATA),
                5 => ::std::option::Option::Some(State::VERIFYING_FILES),
                6 => ::std::option::Option::Some(State::CONNECTING),
                7 => ::std::option::Option::Some(State::DOWNLOADING),
                8 => ::std::option::Option::Some(State::DOWNLOAD_FINISHED),
                9 => ::std::option::Option::Some(State::READY),
                10 => ::std::option::Option::Some(State::PLAYING),
                11 => ::std::option::Option::Some(State::CANCELLED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<State> {
            match str {
                "INITIALIZING" => ::std::option::Option::Some(State::INITIALIZING),
                "STARTING" => ::std::option::Option::Some(State::STARTING),
                "RETRIEVING_SUBTITLES" => ::std::option::Option::Some(State::RETRIEVING_SUBTITLES),
                "DOWNLOADING_SUBTITLE" => ::std::option::Option::Some(State::DOWNLOADING_SUBTITLE),
                "RETRIEVING_METADATA" => ::std::option::Option::Some(State::RETRIEVING_METADATA),
                "VERIFYING_FILES" => ::std::option::Option::Some(State::VERIFYING_FILES),
                "CONNECTING" => ::std::option::Option::Some(State::CONNECTING),
                "DOWNLOADING" => ::std::option::Option::Some(State::DOWNLOADING),
                "DOWNLOAD_FINISHED" => ::std::option::Option::Some(State::DOWNLOAD_FINISHED),
                "READY" => ::std::option::Option::Some(State::READY),
                "PLAYING" => ::std::option::Option::Some(State::PLAYING),
                "CANCELLED" => ::std::option::Option::Some(State::CANCELLED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [State] = &[
            State::INITIALIZING,
            State::STARTING,
            State::RETRIEVING_SUBTITLES,
            State::DOWNLOADING_SUBTITLE,
            State::RETRIEVING_METADATA,
            State::VERIFYING_FILES,
            State::CONNECTING,
            State::DOWNLOADING,
            State::DOWNLOAD_FINISHED,
            State::READY,
            State::PLAYING,
            State::CANCELLED,
        ];
    }

    impl ::std::default::Default for State {
        fn default() -> Self {
            State::INITIALIZING
        }
    }

}

// @@protoc_insertion_point(message:fx.ipc.proto.LoaderLoadRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LoaderLoadRequest {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.LoaderLoadRequest.url)
    pub url: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.LoaderLoadRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoaderLoadRequest {
    fn default() -> &'a LoaderLoadRequest {
        <LoaderLoadRequest as ::protobuf::Message>::default_instance()
    }
}

impl LoaderLoadRequest {
    pub fn new() -> LoaderLoadRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for LoaderLoadRequest {
    const NAME: &'static str = "LoaderLoadRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.url = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.url.is_empty() {
            os.write_string(1, &self.url)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoaderLoadRequest {
        LoaderLoadRequest::new()
    }

    fn clear(&mut self) {
        self.url.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoaderLoadRequest {
        static instance: LoaderLoadRequest = LoaderLoadRequest {
            url: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.LoaderLoadResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LoaderLoadResponse {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.LoaderLoadResponse.handle)
    pub handle: ::protobuf::MessageField<super::message::Handle>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.LoaderLoadResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoaderLoadResponse {
    fn default() -> &'a LoaderLoadResponse {
        <LoaderLoadResponse as ::protobuf::Message>::default_instance()
    }
}

impl LoaderLoadResponse {
    pub fn new() -> LoaderLoadResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for LoaderLoadResponse {
    const NAME: &'static str = "LoaderLoadResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.handle)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.handle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.handle.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoaderLoadResponse {
        LoaderLoadResponse::new()
    }

    fn clear(&mut self) {
        self.handle.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoaderLoadResponse {
        static instance: LoaderLoadResponse = LoaderLoadResponse {
            handle: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.LoaderCancelRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LoaderCancelRequest {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.LoaderCancelRequest.handle)
    pub handle: ::protobuf::MessageField<super::message::Handle>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.LoaderCancelRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoaderCancelRequest {
    fn default() -> &'a LoaderCancelRequest {
        <LoaderCancelRequest as ::protobuf::Message>::default_instance()
    }
}

impl LoaderCancelRequest {
    pub fn new() -> LoaderCancelRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for LoaderCancelRequest {
    const NAME: &'static str = "LoaderCancelRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.handle)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.handle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.handle.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoaderCancelRequest {
        LoaderCancelRequest::new()
    }

    fn clear(&mut self) {
        self.handle.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoaderCancelRequest {
        static instance: LoaderCancelRequest = LoaderCancelRequest {
            handle: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.LoaderEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LoaderEvent {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.LoaderEvent.event)
    pub event: ::protobuf::EnumOrUnknown<loader_event::Event>,
    // @@protoc_insertion_point(field:fx.ipc.proto.LoaderEvent.loading_started)
    pub loading_started: ::protobuf::MessageField<loader_event::LoadingStarted>,
    // @@protoc_insertion_point(field:fx.ipc.proto.LoaderEvent.state_changed)
    pub state_changed: ::protobuf::MessageField<loader_event::StateChanged>,
    // @@protoc_insertion_point(field:fx.ipc.proto.LoaderEvent.progress_changed)
    pub progress_changed: ::protobuf::MessageField<loader_event::ProgressChanged>,
    // @@protoc_insertion_point(field:fx.ipc.proto.LoaderEvent.loading_error)
    pub loading_error: ::protobuf::MessageField<loader_event::LoadingError>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.LoaderEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoaderEvent {
    fn default() -> &'a LoaderEvent {
        <LoaderEvent as ::protobuf::Message>::default_instance()
    }
}

impl LoaderEvent {
    pub fn new() -> LoaderEvent {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for LoaderEvent {
    const NAME: &'static str = "LoaderEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.loading_started)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.state_changed)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.progress_changed)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.loading_error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.event != ::protobuf::EnumOrUnknown::new(loader_event::Event::LOADING_STARTED) {
            my_size += ::protobuf::rt::int32_size(1, self.event.value());
        }
        if let Some(v) = self.loading_started.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.state_changed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.progress_changed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.loading_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.event != ::protobuf::EnumOrUnknown::new(loader_event::Event::LOADING_STARTED) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.event))?;
        }
        if let Some(v) = self.loading_started.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.state_changed.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.progress_changed.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.loading_error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoaderEvent {
        LoaderEvent::new()
    }

    fn clear(&mut self) {
        self.event = ::protobuf::EnumOrUnknown::new(loader_event::Event::LOADING_STARTED);
        self.loading_started.clear();
        self.state_changed.clear();
        self.progress_changed.clear();
        self.loading_error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoaderEvent {
        static instance: LoaderEvent = LoaderEvent {
            event: ::protobuf::EnumOrUnknown::from_i32(0),
            loading_started: ::protobuf::MessageField::none(),
            state_changed: ::protobuf::MessageField::none(),
            progress_changed: ::protobuf::MessageField::none(),
            loading_error: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `LoaderEvent`
pub mod loader_event {
    // @@protoc_insertion_point(message:fx.ipc.proto.LoaderEvent.LoadingStarted)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LoadingStarted {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.LoaderEvent.LoadingStarted.handle)
        pub handle: ::protobuf::MessageField<super::super::message::Handle>,
        // @@protoc_insertion_point(field:fx.ipc.proto.LoaderEvent.LoadingStarted.url)
        pub url: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.LoaderEvent.LoadingStarted.title)
        pub title: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.LoaderEvent.LoadingStarted.thumbnail)
        pub thumbnail: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:fx.ipc.proto.LoaderEvent.LoadingStarted.background)
        pub background: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:fx.ipc.proto.LoaderEvent.LoadingStarted.quality)
        pub quality: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.LoaderEvent.LoadingStarted.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LoadingStarted {
        fn default() -> &'a LoadingStarted {
            <LoadingStarted as ::protobuf::Message>::default_instance()
        }
    }

    impl LoadingStarted {
        pub fn new() -> LoadingStarted {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for LoadingStarted {
        const NAME: &'static str = "LoadingStarted";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.handle)?;
                    },
                    18 => {
                        self.url = is.read_string()?;
                    },
                    26 => {
                        self.title = is.read_string()?;
                    },
                    34 => {
                        self.thumbnail = ::std::option::Option::Some(is.read_string()?);
                    },
                    42 => {
                        self.background = ::std::option::Option::Some(is.read_string()?);
                    },
                    50 => {
                        self.quality = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.handle.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if !self.url.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.url);
            }
            if !self.title.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.title);
            }
            if let Some(v) = self.thumbnail.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.background.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.quality.as_ref() {
                my_size += ::protobuf::rt::string_size(6, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.handle.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if !self.url.is_empty() {
                os.write_string(2, &self.url)?;
            }
            if !self.title.is_empty() {
                os.write_string(3, &self.title)?;
            }
            if let Some(v) = self.thumbnail.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.background.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.quality.as_ref() {
                os.write_string(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LoadingStarted {
            LoadingStarted::new()
        }

        fn clear(&mut self) {
            self.handle.clear();
            self.url.clear();
            self.title.clear();
            self.thumbnail = ::std::option::Option::None;
            self.background = ::std::option::Option::None;
            self.quality = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LoadingStarted {
            static instance: LoadingStarted = LoadingStarted {
                handle: ::protobuf::MessageField::none(),
                url: ::std::string::String::new(),
                title: ::std::string::String::new(),
                thumbnail: ::std::option::Option::None,
                background: ::std::option::Option::None,
                quality: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:fx.ipc.proto.LoaderEvent.StateChanged)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StateChanged {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.LoaderEvent.StateChanged.handle)
        pub handle: ::protobuf::MessageField<super::super::message::Handle>,
        // @@protoc_insertion_point(field:fx.ipc.proto.LoaderEvent.StateChanged.state)
        pub state: ::protobuf::EnumOrUnknown<super::loading::State>,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.LoaderEvent.StateChanged.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StateChanged {
        fn default() -> &'a StateChanged {
            <StateChanged as ::protobuf::Message>::default_instance()
        }
    }

    impl StateChanged {
        pub fn new() -> StateChanged {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for StateChanged {
        const NAME: &'static str = "StateChanged";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.handle)?;
                    },
                    16 => {
                        self.state = is.read_enum_or_unknown()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.handle.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.state != ::protobuf::EnumOrUnknown::new(super::loading::State::INITIALIZING) {
                my_size += ::protobuf::rt::int32_size(2, self.state.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.handle.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if self.state != ::protobuf::EnumOrUnknown::new(super::loading::State::INITIALIZING) {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.state))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StateChanged {
            StateChanged::new()
        }

        fn clear(&mut self) {
            self.handle.clear();
            self.state = ::protobuf::EnumOrUnknown::new(super::loading::State::INITIALIZING);
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StateChanged {
            static instance: StateChanged = StateChanged {
                handle: ::protobuf::MessageField::none(),
                state: ::protobuf::EnumOrUnknown::from_i32(0),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:fx.ipc.proto.LoaderEvent.ProgressChanged)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ProgressChanged {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.LoaderEvent.ProgressChanged.handle)
        pub handle: ::protobuf::MessageField<super::super::message::Handle>,
        // @@protoc_insertion_point(field:fx.ipc.proto.LoaderEvent.ProgressChanged.progress)
        pub progress: ::protobuf::MessageField<super::loading::Progress>,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.LoaderEvent.ProgressChanged.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ProgressChanged {
        fn default() -> &'a ProgressChanged {
            <ProgressChanged as ::protobuf::Message>::default_instance()
        }
    }

    impl ProgressChanged {
        pub fn new() -> ProgressChanged {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for ProgressChanged {
        const NAME: &'static str = "ProgressChanged";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.handle)?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.progress)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.handle.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.progress.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.handle.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.progress.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ProgressChanged {
            ProgressChanged::new()
        }

        fn clear(&mut self) {
            self.handle.clear();
            self.progress.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ProgressChanged {
            static instance: ProgressChanged = ProgressChanged {
                handle: ::protobuf::MessageField::none(),
                progress: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:fx.ipc.proto.LoaderEvent.LoadingError)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LoadingError {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.LoaderEvent.LoadingError.handle)
        pub handle: ::protobuf::MessageField<super::super::message::Handle>,
        // @@protoc_insertion_point(field:fx.ipc.proto.LoaderEvent.LoadingError.error)
        pub error: ::protobuf::MessageField<super::loading::Error>,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.LoaderEvent.LoadingError.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LoadingError {
        fn default() -> &'a LoadingError {
            <LoadingError as ::protobuf::Message>::default_instance()
        }
    }

    impl LoadingError {
        pub fn new() -> LoadingError {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for LoadingError {
        const NAME: &'static str = "LoadingError";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.handle)?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.handle.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.error.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.handle.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.error.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LoadingError {
            LoadingError::new()
        }

        fn clear(&mut self) {
            self.handle.clear();
            self.error.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LoadingError {
            static instance: LoadingError = LoadingError {
                handle: ::protobuf::MessageField::none(),
                error: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:fx.ipc.proto.LoaderEvent.Event)
    pub enum Event {
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.LoaderEvent.Event.LOADING_STARTED)
        LOADING_STARTED = 0,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.LoaderEvent.Event.STATE_CHANGED)
        STATE_CHANGED = 1,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.LoaderEvent.Event.PROGRESS_CHANGED)
        PROGRESS_CHANGED = 2,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.LoaderEvent.Event.LOADING_ERROR)
        LOADING_ERROR = 3,
    }

    impl ::protobuf::Enum for Event {
        const NAME: &'static str = "Event";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Event> {
            match value {
                0 => ::std::option::Option::Some(Event::LOADING_STARTED),
                1 => ::std::option::Option::Some(Event::STATE_CHANGED),
                2 => ::std::option::Option::Some(Event::PROGRESS_CHANGED),
                3 => ::std::option::Option::Some(Event::LOADING_ERROR),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Event> {
            match str {
                "LOADING_STARTED" => ::std::option::Option::Some(Event::LOADING_STARTED),
                "STATE_CHANGED" => ::std::option::Option::Some(Event::STATE_CHANGED),
                "PROGRESS_CHANGED" => ::std::option::Option::Some(Event::PROGRESS_CHANGED),
                "LOADING_ERROR" => ::std::option::Option::Some(Event::LOADING_ERROR),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Event] = &[
            Event::LOADING_STARTED,
            Event::STATE_CHANGED,
            Event::PROGRESS_CHANGED,
            Event::LOADING_ERROR,
        ];
    }

    impl ::std::default::Default for Event {
        fn default() -> Self {
            Event::LOADING_STARTED
        }
    }

}
