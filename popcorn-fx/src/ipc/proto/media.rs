// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by protoc 33.2
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `media.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

// @@protoc_insertion_point(message:fx.ipc.proto.Media)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Media {
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.Media.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Media {
    fn default() -> &'a Media {
        <Media as ::protobuf::Message>::default_instance()
    }
}

impl Media {
    pub fn new() -> Media {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Media {
    const NAME: &'static str = "Media";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Media {
        Media::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Media {
        static instance: Media = Media {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `Media`
pub mod media {
    // @@protoc_insertion_point(message:fx.ipc.proto.Media.MovieOverview)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MovieOverview {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.MovieOverview.title)
        pub title: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.MovieOverview.imdb_id)
        pub imdb_id: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.MovieOverview.year)
        pub year: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.MovieOverview.images)
        pub images: ::protobuf::MessageField<Images>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.MovieOverview.rating)
        pub rating: ::protobuf::MessageField<Rating>,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.Media.MovieOverview.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MovieOverview {
        fn default() -> &'a MovieOverview {
            <MovieOverview as ::protobuf::Message>::default_instance()
        }
    }

    impl MovieOverview {
        pub fn new() -> MovieOverview {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for MovieOverview {
        const NAME: &'static str = "MovieOverview";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.title = is.read_string()?;
                    },
                    18 => {
                        self.imdb_id = is.read_string()?;
                    },
                    26 => {
                        self.year = is.read_string()?;
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.images)?;
                    },
                    42 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.rating)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.title.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.title);
            }
            if !self.imdb_id.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.imdb_id);
            }
            if !self.year.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.year);
            }
            if let Some(v) = self.images.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.rating.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.title.is_empty() {
                os.write_string(1, &self.title)?;
            }
            if !self.imdb_id.is_empty() {
                os.write_string(2, &self.imdb_id)?;
            }
            if !self.year.is_empty() {
                os.write_string(3, &self.year)?;
            }
            if let Some(v) = self.images.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            if let Some(v) = self.rating.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MovieOverview {
            MovieOverview::new()
        }

        fn clear(&mut self) {
            self.title.clear();
            self.imdb_id.clear();
            self.year.clear();
            self.images.clear();
            self.rating.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MovieOverview {
            static instance: MovieOverview = MovieOverview {
                title: ::std::string::String::new(),
                imdb_id: ::std::string::String::new(),
                year: ::std::string::String::new(),
                images: ::protobuf::MessageField::none(),
                rating: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:fx.ipc.proto.Media.ShowOverview)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ShowOverview {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.ShowOverview.imdb_id)
        pub imdb_id: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.ShowOverview.tvdb_id)
        pub tvdb_id: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.ShowOverview.title)
        pub title: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.ShowOverview.year)
        pub year: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.ShowOverview.number_of_seasons)
        pub number_of_seasons: u32,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.ShowOverview.images)
        pub images: ::protobuf::MessageField<Images>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.ShowOverview.rating)
        pub rating: ::protobuf::MessageField<Rating>,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.Media.ShowOverview.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ShowOverview {
        fn default() -> &'a ShowOverview {
            <ShowOverview as ::protobuf::Message>::default_instance()
        }
    }

    impl ShowOverview {
        pub fn new() -> ShowOverview {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for ShowOverview {
        const NAME: &'static str = "ShowOverview";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.imdb_id = is.read_string()?;
                    },
                    18 => {
                        self.tvdb_id = is.read_string()?;
                    },
                    26 => {
                        self.title = is.read_string()?;
                    },
                    34 => {
                        self.year = is.read_string()?;
                    },
                    40 => {
                        self.number_of_seasons = is.read_uint32()?;
                    },
                    50 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.images)?;
                    },
                    58 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.rating)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.imdb_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.imdb_id);
            }
            if !self.tvdb_id.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.tvdb_id);
            }
            if !self.title.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.title);
            }
            if !self.year.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.year);
            }
            if self.number_of_seasons != 0 {
                my_size += ::protobuf::rt::uint32_size(5, self.number_of_seasons);
            }
            if let Some(v) = self.images.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.rating.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.imdb_id.is_empty() {
                os.write_string(1, &self.imdb_id)?;
            }
            if !self.tvdb_id.is_empty() {
                os.write_string(2, &self.tvdb_id)?;
            }
            if !self.title.is_empty() {
                os.write_string(3, &self.title)?;
            }
            if !self.year.is_empty() {
                os.write_string(4, &self.year)?;
            }
            if self.number_of_seasons != 0 {
                os.write_uint32(5, self.number_of_seasons)?;
            }
            if let Some(v) = self.images.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            }
            if let Some(v) = self.rating.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ShowOverview {
            ShowOverview::new()
        }

        fn clear(&mut self) {
            self.imdb_id.clear();
            self.tvdb_id.clear();
            self.title.clear();
            self.year.clear();
            self.number_of_seasons = 0;
            self.images.clear();
            self.rating.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ShowOverview {
            static instance: ShowOverview = ShowOverview {
                imdb_id: ::std::string::String::new(),
                tvdb_id: ::std::string::String::new(),
                title: ::std::string::String::new(),
                year: ::std::string::String::new(),
                number_of_seasons: 0,
                images: ::protobuf::MessageField::none(),
                rating: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:fx.ipc.proto.Media.MovieDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MovieDetails {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.MovieDetails.title)
        pub title: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.MovieDetails.imdb_id)
        pub imdb_id: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.MovieDetails.year)
        pub year: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.MovieDetails.images)
        pub images: ::protobuf::MessageField<Images>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.MovieDetails.rating)
        pub rating: ::protobuf::MessageField<Rating>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.MovieDetails.synopsis)
        pub synopsis: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.MovieDetails.runtime)
        pub runtime: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.MovieDetails.trailer)
        pub trailer: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.MovieDetails.genres)
        pub genres: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.MovieDetails.torrents)
        pub torrents: ::std::vec::Vec<TorrentLanguage>,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.Media.MovieDetails.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MovieDetails {
        fn default() -> &'a MovieDetails {
            <MovieDetails as ::protobuf::Message>::default_instance()
        }
    }

    impl MovieDetails {
        pub fn new() -> MovieDetails {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for MovieDetails {
        const NAME: &'static str = "MovieDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.title = is.read_string()?;
                    },
                    18 => {
                        self.imdb_id = is.read_string()?;
                    },
                    26 => {
                        self.year = is.read_string()?;
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.images)?;
                    },
                    42 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.rating)?;
                    },
                    50 => {
                        self.synopsis = is.read_string()?;
                    },
                    56 => {
                        self.runtime = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    66 => {
                        self.trailer = ::std::option::Option::Some(is.read_string()?);
                    },
                    74 => {
                        self.genres.push(is.read_string()?);
                    },
                    82 => {
                        self.torrents.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.title.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.title);
            }
            if !self.imdb_id.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.imdb_id);
            }
            if !self.year.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.year);
            }
            if let Some(v) = self.images.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.rating.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if !self.synopsis.is_empty() {
                my_size += ::protobuf::rt::string_size(6, &self.synopsis);
            }
            if let Some(v) = self.runtime {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.trailer.as_ref() {
                my_size += ::protobuf::rt::string_size(8, &v);
            }
            for value in &self.genres {
                my_size += ::protobuf::rt::string_size(9, &value);
            };
            for value in &self.torrents {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.title.is_empty() {
                os.write_string(1, &self.title)?;
            }
            if !self.imdb_id.is_empty() {
                os.write_string(2, &self.imdb_id)?;
            }
            if !self.year.is_empty() {
                os.write_string(3, &self.year)?;
            }
            if let Some(v) = self.images.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            if let Some(v) = self.rating.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            if !self.synopsis.is_empty() {
                os.write_string(6, &self.synopsis)?;
            }
            if let Some(v) = self.runtime {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.trailer.as_ref() {
                os.write_string(8, v)?;
            }
            for v in &self.genres {
                os.write_string(9, &v)?;
            };
            for v in &self.torrents {
                ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MovieDetails {
            MovieDetails::new()
        }

        fn clear(&mut self) {
            self.title.clear();
            self.imdb_id.clear();
            self.year.clear();
            self.images.clear();
            self.rating.clear();
            self.synopsis.clear();
            self.runtime = ::std::option::Option::None;
            self.trailer = ::std::option::Option::None;
            self.genres.clear();
            self.torrents.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MovieDetails {
            static instance: MovieDetails = MovieDetails {
                title: ::std::string::String::new(),
                imdb_id: ::std::string::String::new(),
                year: ::std::string::String::new(),
                images: ::protobuf::MessageField::none(),
                rating: ::protobuf::MessageField::none(),
                synopsis: ::std::string::String::new(),
                runtime: ::std::option::Option::None,
                trailer: ::std::option::Option::None,
                genres: ::std::vec::Vec::new(),
                torrents: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:fx.ipc.proto.Media.ShowDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ShowDetails {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.ShowDetails.imdb_id)
        pub imdb_id: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.ShowDetails.tvdb_id)
        pub tvdb_id: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.ShowDetails.title)
        pub title: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.ShowDetails.year)
        pub year: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.ShowDetails.number_of_seasons)
        pub number_of_seasons: u32,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.ShowDetails.images)
        pub images: ::protobuf::MessageField<Images>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.ShowDetails.rating)
        pub rating: ::protobuf::MessageField<Rating>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.ShowDetails.synopsis)
        pub synopsis: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.ShowDetails.runtime)
        pub runtime: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.ShowDetails.status)
        pub status: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.ShowDetails.genre)
        pub genre: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.ShowDetails.episodes)
        pub episodes: ::std::vec::Vec<Episode>,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.Media.ShowDetails.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ShowDetails {
        fn default() -> &'a ShowDetails {
            <ShowDetails as ::protobuf::Message>::default_instance()
        }
    }

    impl ShowDetails {
        pub fn new() -> ShowDetails {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for ShowDetails {
        const NAME: &'static str = "ShowDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.imdb_id = is.read_string()?;
                    },
                    18 => {
                        self.tvdb_id = is.read_string()?;
                    },
                    26 => {
                        self.title = is.read_string()?;
                    },
                    34 => {
                        self.year = is.read_string()?;
                    },
                    40 => {
                        self.number_of_seasons = is.read_uint32()?;
                    },
                    50 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.images)?;
                    },
                    58 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.rating)?;
                    },
                    66 => {
                        self.synopsis = ::std::option::Option::Some(is.read_string()?);
                    },
                    72 => {
                        self.runtime = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    82 => {
                        self.status = ::std::option::Option::Some(is.read_string()?);
                    },
                    90 => {
                        self.genre.push(is.read_string()?);
                    },
                    98 => {
                        self.episodes.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.imdb_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.imdb_id);
            }
            if !self.tvdb_id.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.tvdb_id);
            }
            if !self.title.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.title);
            }
            if !self.year.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.year);
            }
            if self.number_of_seasons != 0 {
                my_size += ::protobuf::rt::uint32_size(5, self.number_of_seasons);
            }
            if let Some(v) = self.images.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.rating.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.synopsis.as_ref() {
                my_size += ::protobuf::rt::string_size(8, &v);
            }
            if let Some(v) = self.runtime {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.status.as_ref() {
                my_size += ::protobuf::rt::string_size(10, &v);
            }
            for value in &self.genre {
                my_size += ::protobuf::rt::string_size(11, &value);
            };
            for value in &self.episodes {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.imdb_id.is_empty() {
                os.write_string(1, &self.imdb_id)?;
            }
            if !self.tvdb_id.is_empty() {
                os.write_string(2, &self.tvdb_id)?;
            }
            if !self.title.is_empty() {
                os.write_string(3, &self.title)?;
            }
            if !self.year.is_empty() {
                os.write_string(4, &self.year)?;
            }
            if self.number_of_seasons != 0 {
                os.write_uint32(5, self.number_of_seasons)?;
            }
            if let Some(v) = self.images.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            }
            if let Some(v) = self.rating.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            }
            if let Some(v) = self.synopsis.as_ref() {
                os.write_string(8, v)?;
            }
            if let Some(v) = self.runtime {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.status.as_ref() {
                os.write_string(10, v)?;
            }
            for v in &self.genre {
                os.write_string(11, &v)?;
            };
            for v in &self.episodes {
                ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ShowDetails {
            ShowDetails::new()
        }

        fn clear(&mut self) {
            self.imdb_id.clear();
            self.tvdb_id.clear();
            self.title.clear();
            self.year.clear();
            self.number_of_seasons = 0;
            self.images.clear();
            self.rating.clear();
            self.synopsis = ::std::option::Option::None;
            self.runtime = ::std::option::Option::None;
            self.status = ::std::option::Option::None;
            self.genre.clear();
            self.episodes.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ShowDetails {
            static instance: ShowDetails = ShowDetails {
                imdb_id: ::std::string::String::new(),
                tvdb_id: ::std::string::String::new(),
                title: ::std::string::String::new(),
                year: ::std::string::String::new(),
                number_of_seasons: 0,
                images: ::protobuf::MessageField::none(),
                rating: ::protobuf::MessageField::none(),
                synopsis: ::std::option::Option::None,
                runtime: ::std::option::Option::None,
                status: ::std::option::Option::None,
                genre: ::std::vec::Vec::new(),
                episodes: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:fx.ipc.proto.Media.Episode)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Episode {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Episode.season)
        pub season: u32,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Episode.episode)
        pub episode: u32,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Episode.first_aired)
        pub first_aired: u64,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Episode.title)
        pub title: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Episode.synopsis)
        pub synopsis: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Episode.tvdb_id)
        pub tvdb_id: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Episode.thumb)
        pub thumb: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Episode.torrents)
        pub torrents: ::protobuf::MessageField<TorrentQuality>,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.Media.Episode.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Episode {
        fn default() -> &'a Episode {
            <Episode as ::protobuf::Message>::default_instance()
        }
    }

    impl Episode {
        pub fn new() -> Episode {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for Episode {
        const NAME: &'static str = "Episode";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.season = is.read_uint32()?;
                    },
                    16 => {
                        self.episode = is.read_uint32()?;
                    },
                    24 => {
                        self.first_aired = is.read_uint64()?;
                    },
                    34 => {
                        self.title = is.read_string()?;
                    },
                    42 => {
                        self.synopsis = is.read_string()?;
                    },
                    50 => {
                        self.tvdb_id = is.read_string()?;
                    },
                    58 => {
                        self.thumb = ::std::option::Option::Some(is.read_string()?);
                    },
                    66 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.torrents)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.season != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.season);
            }
            if self.episode != 0 {
                my_size += ::protobuf::rt::uint32_size(2, self.episode);
            }
            if self.first_aired != 0 {
                my_size += ::protobuf::rt::uint64_size(3, self.first_aired);
            }
            if !self.title.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.title);
            }
            if !self.synopsis.is_empty() {
                my_size += ::protobuf::rt::string_size(5, &self.synopsis);
            }
            if !self.tvdb_id.is_empty() {
                my_size += ::protobuf::rt::string_size(6, &self.tvdb_id);
            }
            if let Some(v) = self.thumb.as_ref() {
                my_size += ::protobuf::rt::string_size(7, &v);
            }
            if let Some(v) = self.torrents.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.season != 0 {
                os.write_uint32(1, self.season)?;
            }
            if self.episode != 0 {
                os.write_uint32(2, self.episode)?;
            }
            if self.first_aired != 0 {
                os.write_uint64(3, self.first_aired)?;
            }
            if !self.title.is_empty() {
                os.write_string(4, &self.title)?;
            }
            if !self.synopsis.is_empty() {
                os.write_string(5, &self.synopsis)?;
            }
            if !self.tvdb_id.is_empty() {
                os.write_string(6, &self.tvdb_id)?;
            }
            if let Some(v) = self.thumb.as_ref() {
                os.write_string(7, v)?;
            }
            if let Some(v) = self.torrents.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Episode {
            Episode::new()
        }

        fn clear(&mut self) {
            self.season = 0;
            self.episode = 0;
            self.first_aired = 0;
            self.title.clear();
            self.synopsis.clear();
            self.tvdb_id.clear();
            self.thumb = ::std::option::Option::None;
            self.torrents.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Episode {
            static instance: Episode = Episode {
                season: 0,
                episode: 0,
                first_aired: 0,
                title: ::std::string::String::new(),
                synopsis: ::std::string::String::new(),
                tvdb_id: ::std::string::String::new(),
                thumb: ::std::option::Option::None,
                torrents: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:fx.ipc.proto.Media.Rating)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Rating {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Rating.percentage)
        pub percentage: u32,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Rating.watching)
        pub watching: u32,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Rating.votes)
        pub votes: u32,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Rating.loved)
        pub loved: u32,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Rating.hated)
        pub hated: u32,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.Media.Rating.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Rating {
        fn default() -> &'a Rating {
            <Rating as ::protobuf::Message>::default_instance()
        }
    }

    impl Rating {
        pub fn new() -> Rating {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for Rating {
        const NAME: &'static str = "Rating";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.percentage = is.read_uint32()?;
                    },
                    16 => {
                        self.watching = is.read_uint32()?;
                    },
                    24 => {
                        self.votes = is.read_uint32()?;
                    },
                    32 => {
                        self.loved = is.read_uint32()?;
                    },
                    40 => {
                        self.hated = is.read_uint32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.percentage != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.percentage);
            }
            if self.watching != 0 {
                my_size += ::protobuf::rt::uint32_size(2, self.watching);
            }
            if self.votes != 0 {
                my_size += ::protobuf::rt::uint32_size(3, self.votes);
            }
            if self.loved != 0 {
                my_size += ::protobuf::rt::uint32_size(4, self.loved);
            }
            if self.hated != 0 {
                my_size += ::protobuf::rt::uint32_size(5, self.hated);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.percentage != 0 {
                os.write_uint32(1, self.percentage)?;
            }
            if self.watching != 0 {
                os.write_uint32(2, self.watching)?;
            }
            if self.votes != 0 {
                os.write_uint32(3, self.votes)?;
            }
            if self.loved != 0 {
                os.write_uint32(4, self.loved)?;
            }
            if self.hated != 0 {
                os.write_uint32(5, self.hated)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Rating {
            Rating::new()
        }

        fn clear(&mut self) {
            self.percentage = 0;
            self.watching = 0;
            self.votes = 0;
            self.loved = 0;
            self.hated = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Rating {
            static instance: Rating = Rating {
                percentage: 0,
                watching: 0,
                votes: 0,
                loved: 0,
                hated: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:fx.ipc.proto.Media.Images)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Images {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Images.poster)
        pub poster: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Images.banner)
        pub banner: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Images.fanart)
        pub fanart: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.Media.Images.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Images {
        fn default() -> &'a Images {
            <Images as ::protobuf::Message>::default_instance()
        }
    }

    impl Images {
        pub fn new() -> Images {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for Images {
        const NAME: &'static str = "Images";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.poster = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.banner = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.fanart = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.poster.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.banner.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.fanart.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.poster.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.banner.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.fanart.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Images {
            Images::new()
        }

        fn clear(&mut self) {
            self.poster = ::std::option::Option::None;
            self.banner = ::std::option::Option::None;
            self.fanart = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Images {
            static instance: Images = Images {
                poster: ::std::option::Option::None,
                banner: ::std::option::Option::None,
                fanart: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:fx.ipc.proto.Media.TorrentLanguage)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TorrentLanguage {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.TorrentLanguage.language)
        pub language: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.TorrentLanguage.torrents)
        pub torrents: ::protobuf::MessageField<TorrentQuality>,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.Media.TorrentLanguage.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TorrentLanguage {
        fn default() -> &'a TorrentLanguage {
            <TorrentLanguage as ::protobuf::Message>::default_instance()
        }
    }

    impl TorrentLanguage {
        pub fn new() -> TorrentLanguage {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for TorrentLanguage {
        const NAME: &'static str = "TorrentLanguage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.language = is.read_string()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.torrents)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.language.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.language);
            }
            if let Some(v) = self.torrents.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.language.is_empty() {
                os.write_string(1, &self.language)?;
            }
            if let Some(v) = self.torrents.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TorrentLanguage {
            TorrentLanguage::new()
        }

        fn clear(&mut self) {
            self.language.clear();
            self.torrents.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TorrentLanguage {
            static instance: TorrentLanguage = TorrentLanguage {
                language: ::std::string::String::new(),
                torrents: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:fx.ipc.proto.Media.TorrentQuality)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TorrentQuality {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.TorrentQuality.qualities)
        pub qualities: ::std::collections::HashMap<::std::string::String, TorrentInfo>,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.Media.TorrentQuality.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TorrentQuality {
        fn default() -> &'a TorrentQuality {
            <TorrentQuality as ::protobuf::Message>::default_instance()
        }
    }

    impl TorrentQuality {
        pub fn new() -> TorrentQuality {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for TorrentQuality {
        const NAME: &'static str = "TorrentQuality";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_message()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.qualities.insert(key, value);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for (k, v) in &self.qualities {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                let len = v.compute_size();
                entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for (k, v) in &self.qualities {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                let len = v.cached_size() as u64;
                entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                os.write_raw_varint32(10)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TorrentQuality {
            TorrentQuality::new()
        }

        fn clear(&mut self) {
            self.qualities.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TorrentQuality {
            static instance: ::protobuf::rt::Lazy<TorrentQuality> = ::protobuf::rt::Lazy::new();
            instance.get(TorrentQuality::new)
        }
    }

    // @@protoc_insertion_point(message:fx.ipc.proto.Media.TorrentInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TorrentInfo {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.TorrentInfo.url)
        pub url: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.TorrentInfo.provider)
        pub provider: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.TorrentInfo.source)
        pub source: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.TorrentInfo.title)
        pub title: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.TorrentInfo.quality)
        pub quality: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.TorrentInfo.seeds)
        pub seeds: u32,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.TorrentInfo.peers)
        pub peers: u32,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.TorrentInfo.size)
        pub size: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.TorrentInfo.file_size)
        pub file_size: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.TorrentInfo.file)
        pub file: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.Media.TorrentInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TorrentInfo {
        fn default() -> &'a TorrentInfo {
            <TorrentInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl TorrentInfo {
        pub fn new() -> TorrentInfo {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for TorrentInfo {
        const NAME: &'static str = "TorrentInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.url = is.read_string()?;
                    },
                    18 => {
                        self.provider = is.read_string()?;
                    },
                    26 => {
                        self.source = is.read_string()?;
                    },
                    34 => {
                        self.title = is.read_string()?;
                    },
                    42 => {
                        self.quality = is.read_string()?;
                    },
                    48 => {
                        self.seeds = is.read_uint32()?;
                    },
                    56 => {
                        self.peers = is.read_uint32()?;
                    },
                    66 => {
                        self.size = ::std::option::Option::Some(is.read_string()?);
                    },
                    74 => {
                        self.file_size = ::std::option::Option::Some(is.read_string()?);
                    },
                    82 => {
                        self.file = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.url.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.url);
            }
            if !self.provider.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.provider);
            }
            if !self.source.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.source);
            }
            if !self.title.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.title);
            }
            if !self.quality.is_empty() {
                my_size += ::protobuf::rt::string_size(5, &self.quality);
            }
            if self.seeds != 0 {
                my_size += ::protobuf::rt::uint32_size(6, self.seeds);
            }
            if self.peers != 0 {
                my_size += ::protobuf::rt::uint32_size(7, self.peers);
            }
            if let Some(v) = self.size.as_ref() {
                my_size += ::protobuf::rt::string_size(8, &v);
            }
            if let Some(v) = self.file_size.as_ref() {
                my_size += ::protobuf::rt::string_size(9, &v);
            }
            if let Some(v) = self.file.as_ref() {
                my_size += ::protobuf::rt::string_size(10, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.url.is_empty() {
                os.write_string(1, &self.url)?;
            }
            if !self.provider.is_empty() {
                os.write_string(2, &self.provider)?;
            }
            if !self.source.is_empty() {
                os.write_string(3, &self.source)?;
            }
            if !self.title.is_empty() {
                os.write_string(4, &self.title)?;
            }
            if !self.quality.is_empty() {
                os.write_string(5, &self.quality)?;
            }
            if self.seeds != 0 {
                os.write_uint32(6, self.seeds)?;
            }
            if self.peers != 0 {
                os.write_uint32(7, self.peers)?;
            }
            if let Some(v) = self.size.as_ref() {
                os.write_string(8, v)?;
            }
            if let Some(v) = self.file_size.as_ref() {
                os.write_string(9, v)?;
            }
            if let Some(v) = self.file.as_ref() {
                os.write_string(10, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TorrentInfo {
            TorrentInfo::new()
        }

        fn clear(&mut self) {
            self.url.clear();
            self.provider.clear();
            self.source.clear();
            self.title.clear();
            self.quality.clear();
            self.seeds = 0;
            self.peers = 0;
            self.size = ::std::option::Option::None;
            self.file_size = ::std::option::Option::None;
            self.file = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TorrentInfo {
            static instance: TorrentInfo = TorrentInfo {
                url: ::std::string::String::new(),
                provider: ::std::string::String::new(),
                source: ::std::string::String::new(),
                title: ::std::string::String::new(),
                quality: ::std::string::String::new(),
                seeds: 0,
                peers: 0,
                size: ::std::option::Option::None,
                file_size: ::std::option::Option::None,
                file: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:fx.ipc.proto.Media.Genre)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Genre {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Genre.key)
        pub key: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Genre.text)
        pub text: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.Media.Genre.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Genre {
        fn default() -> &'a Genre {
            <Genre as ::protobuf::Message>::default_instance()
        }
    }

    impl Genre {
        pub fn new() -> Genre {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for Genre {
        const NAME: &'static str = "Genre";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.key = is.read_string()?;
                    },
                    18 => {
                        self.text = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.key.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.key);
            }
            if !self.text.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.text);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.key.is_empty() {
                os.write_string(1, &self.key)?;
            }
            if !self.text.is_empty() {
                os.write_string(2, &self.text)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Genre {
            Genre::new()
        }

        fn clear(&mut self) {
            self.key.clear();
            self.text.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Genre {
            static instance: Genre = Genre {
                key: ::std::string::String::new(),
                text: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:fx.ipc.proto.Media.SortBy)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SortBy {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.SortBy.key)
        pub key: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.SortBy.text)
        pub text: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.Media.SortBy.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SortBy {
        fn default() -> &'a SortBy {
            <SortBy as ::protobuf::Message>::default_instance()
        }
    }

    impl SortBy {
        pub fn new() -> SortBy {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for SortBy {
        const NAME: &'static str = "SortBy";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.key = is.read_string()?;
                    },
                    18 => {
                        self.text = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.key.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.key);
            }
            if !self.text.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.text);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.key.is_empty() {
                os.write_string(1, &self.key)?;
            }
            if !self.text.is_empty() {
                os.write_string(2, &self.text)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SortBy {
            SortBy::new()
        }

        fn clear(&mut self) {
            self.key.clear();
            self.text.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SortBy {
            static instance: SortBy = SortBy {
                key: ::std::string::String::new(),
                text: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:fx.ipc.proto.Media.Item)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Item {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Item.type)
        pub type_: ::std::string::String,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Item.movie_overview)
        pub movie_overview: ::protobuf::MessageField<MovieOverview>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Item.show_overview)
        pub show_overview: ::protobuf::MessageField<ShowOverview>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Item.movie_details)
        pub movie_details: ::protobuf::MessageField<MovieDetails>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Item.show_details)
        pub show_details: ::protobuf::MessageField<ShowDetails>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Item.episode)
        pub episode: ::protobuf::MessageField<Episode>,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.Media.Item.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Item {
        fn default() -> &'a Item {
            <Item as ::protobuf::Message>::default_instance()
        }
    }

    impl Item {
        pub fn new() -> Item {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for Item {
        const NAME: &'static str = "Item";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.type_ = is.read_string()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.movie_overview)?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.show_overview)?;
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.movie_details)?;
                    },
                    42 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.show_details)?;
                    },
                    50 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.episode)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.type_.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.type_);
            }
            if let Some(v) = self.movie_overview.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.show_overview.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.movie_details.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.show_details.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.episode.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.type_.is_empty() {
                os.write_string(1, &self.type_)?;
            }
            if let Some(v) = self.movie_overview.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.show_overview.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.movie_details.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            if let Some(v) = self.show_details.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            if let Some(v) = self.episode.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Item {
            Item::new()
        }

        fn clear(&mut self) {
            self.type_.clear();
            self.movie_overview.clear();
            self.show_overview.clear();
            self.movie_details.clear();
            self.show_details.clear();
            self.episode.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Item {
            static instance: Item = Item {
                type_: ::std::string::String::new(),
                movie_overview: ::protobuf::MessageField::none(),
                show_overview: ::protobuf::MessageField::none(),
                movie_details: ::protobuf::MessageField::none(),
                show_details: ::protobuf::MessageField::none(),
                episode: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:fx.ipc.proto.Media.Error)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Error {
        // message fields
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Error.type)
        pub type_: ::protobuf::EnumOrUnknown<error::Type>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Error.favorite_loading_failed)
        pub favorite_loading_failed: ::protobuf::MessageField<error::FavoritesLoadingFailed>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Error.favorite_not_found)
        pub favorite_not_found: ::protobuf::MessageField<error::FavoriteNotFound>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Error.favorite_add_failed)
        pub favorite_add_failed: ::protobuf::MessageField<error::FavoriteAddFailed>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Error.watched_loading_failed)
        pub watched_loading_failed: ::protobuf::MessageField<error::WatchedLoadingFailed>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Error.media_type_not_supported)
        pub media_type_not_supported: ::protobuf::MessageField<error::MediaTypeNotSupported>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Error.provider_request_failed)
        pub provider_request_failed: ::protobuf::MessageField<error::ProviderRequestFailed>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Error.provider_parsing_failed)
        pub provider_parsing_failed: ::protobuf::MessageField<error::ProviderParsingFailed>,
        // @@protoc_insertion_point(field:fx.ipc.proto.Media.Error.provider_not_found)
        pub provider_not_found: ::protobuf::MessageField<error::ProviderNotFound>,
        // special fields
        // @@protoc_insertion_point(special_field:fx.ipc.proto.Media.Error.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Error {
        fn default() -> &'a Error {
            <Error as ::protobuf::Message>::default_instance()
        }
    }

    impl Error {
        pub fn new() -> Error {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for Error {
        const NAME: &'static str = "Error";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = is.read_enum_or_unknown()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.favorite_loading_failed)?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.favorite_not_found)?;
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.favorite_add_failed)?;
                    },
                    42 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.watched_loading_failed)?;
                    },
                    50 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.media_type_not_supported)?;
                    },
                    58 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.provider_request_failed)?;
                    },
                    66 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.provider_parsing_failed)?;
                    },
                    74 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.provider_not_found)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.type_ != ::protobuf::EnumOrUnknown::new(error::Type::FAVORITES_LOADING_FAILED) {
                my_size += ::protobuf::rt::int32_size(1, self.type_.value());
            }
            if let Some(v) = self.favorite_loading_failed.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.favorite_not_found.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.favorite_add_failed.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.watched_loading_failed.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.media_type_not_supported.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.provider_request_failed.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.provider_parsing_failed.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.provider_not_found.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.type_ != ::protobuf::EnumOrUnknown::new(error::Type::FAVORITES_LOADING_FAILED) {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
            }
            if let Some(v) = self.favorite_loading_failed.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.favorite_not_found.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.favorite_add_failed.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            if let Some(v) = self.watched_loading_failed.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            if let Some(v) = self.media_type_not_supported.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            }
            if let Some(v) = self.provider_request_failed.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            }
            if let Some(v) = self.provider_parsing_failed.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
            }
            if let Some(v) = self.provider_not_found.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Error {
            Error::new()
        }

        fn clear(&mut self) {
            self.type_ = ::protobuf::EnumOrUnknown::new(error::Type::FAVORITES_LOADING_FAILED);
            self.favorite_loading_failed.clear();
            self.favorite_not_found.clear();
            self.favorite_add_failed.clear();
            self.watched_loading_failed.clear();
            self.media_type_not_supported.clear();
            self.provider_request_failed.clear();
            self.provider_parsing_failed.clear();
            self.provider_not_found.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Error {
            static instance: Error = Error {
                type_: ::protobuf::EnumOrUnknown::from_i32(0),
                favorite_loading_failed: ::protobuf::MessageField::none(),
                favorite_not_found: ::protobuf::MessageField::none(),
                favorite_add_failed: ::protobuf::MessageField::none(),
                watched_loading_failed: ::protobuf::MessageField::none(),
                media_type_not_supported: ::protobuf::MessageField::none(),
                provider_request_failed: ::protobuf::MessageField::none(),
                provider_parsing_failed: ::protobuf::MessageField::none(),
                provider_not_found: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Error`
    pub mod error {
        // @@protoc_insertion_point(message:fx.ipc.proto.Media.Error.FavoritesLoadingFailed)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct FavoritesLoadingFailed {
            // message fields
            // @@protoc_insertion_point(field:fx.ipc.proto.Media.Error.FavoritesLoadingFailed.reason)
            pub reason: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:fx.ipc.proto.Media.Error.FavoritesLoadingFailed.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a FavoritesLoadingFailed {
            fn default() -> &'a FavoritesLoadingFailed {
                <FavoritesLoadingFailed as ::protobuf::Message>::default_instance()
            }
        }

        impl FavoritesLoadingFailed {
            pub fn new() -> FavoritesLoadingFailed {
                ::std::default::Default::default()
            }
        }

        impl ::protobuf::Message for FavoritesLoadingFailed {
            const NAME: &'static str = "FavoritesLoadingFailed";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.reason = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.reason.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.reason);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.reason.is_empty() {
                    os.write_string(1, &self.reason)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> FavoritesLoadingFailed {
                FavoritesLoadingFailed::new()
            }

            fn clear(&mut self) {
                self.reason.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static FavoritesLoadingFailed {
                static instance: FavoritesLoadingFailed = FavoritesLoadingFailed {
                    reason: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:fx.ipc.proto.Media.Error.FavoriteNotFound)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct FavoriteNotFound {
            // message fields
            // @@protoc_insertion_point(field:fx.ipc.proto.Media.Error.FavoriteNotFound.imdb_id)
            pub imdb_id: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:fx.ipc.proto.Media.Error.FavoriteNotFound.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a FavoriteNotFound {
            fn default() -> &'a FavoriteNotFound {
                <FavoriteNotFound as ::protobuf::Message>::default_instance()
            }
        }

        impl FavoriteNotFound {
            pub fn new() -> FavoriteNotFound {
                ::std::default::Default::default()
            }
        }

        impl ::protobuf::Message for FavoriteNotFound {
            const NAME: &'static str = "FavoriteNotFound";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.imdb_id = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.imdb_id.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.imdb_id);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.imdb_id.is_empty() {
                    os.write_string(1, &self.imdb_id)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> FavoriteNotFound {
                FavoriteNotFound::new()
            }

            fn clear(&mut self) {
                self.imdb_id.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static FavoriteNotFound {
                static instance: FavoriteNotFound = FavoriteNotFound {
                    imdb_id: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:fx.ipc.proto.Media.Error.FavoriteAddFailed)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct FavoriteAddFailed {
            // message fields
            // @@protoc_insertion_point(field:fx.ipc.proto.Media.Error.FavoriteAddFailed.imdb_id)
            pub imdb_id: ::std::string::String,
            // @@protoc_insertion_point(field:fx.ipc.proto.Media.Error.FavoriteAddFailed.reason)
            pub reason: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:fx.ipc.proto.Media.Error.FavoriteAddFailed.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a FavoriteAddFailed {
            fn default() -> &'a FavoriteAddFailed {
                <FavoriteAddFailed as ::protobuf::Message>::default_instance()
            }
        }

        impl FavoriteAddFailed {
            pub fn new() -> FavoriteAddFailed {
                ::std::default::Default::default()
            }
        }

        impl ::protobuf::Message for FavoriteAddFailed {
            const NAME: &'static str = "FavoriteAddFailed";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.imdb_id = is.read_string()?;
                        },
                        18 => {
                            self.reason = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.imdb_id.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.imdb_id);
                }
                if !self.reason.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.reason);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.imdb_id.is_empty() {
                    os.write_string(1, &self.imdb_id)?;
                }
                if !self.reason.is_empty() {
                    os.write_string(2, &self.reason)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> FavoriteAddFailed {
                FavoriteAddFailed::new()
            }

            fn clear(&mut self) {
                self.imdb_id.clear();
                self.reason.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static FavoriteAddFailed {
                static instance: FavoriteAddFailed = FavoriteAddFailed {
                    imdb_id: ::std::string::String::new(),
                    reason: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:fx.ipc.proto.Media.Error.WatchedLoadingFailed)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct WatchedLoadingFailed {
            // message fields
            // @@protoc_insertion_point(field:fx.ipc.proto.Media.Error.WatchedLoadingFailed.reason)
            pub reason: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:fx.ipc.proto.Media.Error.WatchedLoadingFailed.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a WatchedLoadingFailed {
            fn default() -> &'a WatchedLoadingFailed {
                <WatchedLoadingFailed as ::protobuf::Message>::default_instance()
            }
        }

        impl WatchedLoadingFailed {
            pub fn new() -> WatchedLoadingFailed {
                ::std::default::Default::default()
            }
        }

        impl ::protobuf::Message for WatchedLoadingFailed {
            const NAME: &'static str = "WatchedLoadingFailed";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.reason = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.reason.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.reason);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.reason.is_empty() {
                    os.write_string(1, &self.reason)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> WatchedLoadingFailed {
                WatchedLoadingFailed::new()
            }

            fn clear(&mut self) {
                self.reason.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static WatchedLoadingFailed {
                static instance: WatchedLoadingFailed = WatchedLoadingFailed {
                    reason: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:fx.ipc.proto.Media.Error.MediaTypeNotSupported)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct MediaTypeNotSupported {
            // message fields
            // @@protoc_insertion_point(field:fx.ipc.proto.Media.Error.MediaTypeNotSupported.type)
            pub type_: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:fx.ipc.proto.Media.Error.MediaTypeNotSupported.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a MediaTypeNotSupported {
            fn default() -> &'a MediaTypeNotSupported {
                <MediaTypeNotSupported as ::protobuf::Message>::default_instance()
            }
        }

        impl MediaTypeNotSupported {
            pub fn new() -> MediaTypeNotSupported {
                ::std::default::Default::default()
            }
        }

        impl ::protobuf::Message for MediaTypeNotSupported {
            const NAME: &'static str = "MediaTypeNotSupported";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.type_ = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.type_.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.type_);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.type_.is_empty() {
                    os.write_string(1, &self.type_)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> MediaTypeNotSupported {
                MediaTypeNotSupported::new()
            }

            fn clear(&mut self) {
                self.type_.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static MediaTypeNotSupported {
                static instance: MediaTypeNotSupported = MediaTypeNotSupported {
                    type_: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:fx.ipc.proto.Media.Error.ProviderRequestFailed)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ProviderRequestFailed {
            // message fields
            // @@protoc_insertion_point(field:fx.ipc.proto.Media.Error.ProviderRequestFailed.url)
            pub url: ::std::string::String,
            // @@protoc_insertion_point(field:fx.ipc.proto.Media.Error.ProviderRequestFailed.status_code)
            pub status_code: u32,
            // special fields
            // @@protoc_insertion_point(special_field:fx.ipc.proto.Media.Error.ProviderRequestFailed.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ProviderRequestFailed {
            fn default() -> &'a ProviderRequestFailed {
                <ProviderRequestFailed as ::protobuf::Message>::default_instance()
            }
        }

        impl ProviderRequestFailed {
            pub fn new() -> ProviderRequestFailed {
                ::std::default::Default::default()
            }
        }

        impl ::protobuf::Message for ProviderRequestFailed {
            const NAME: &'static str = "ProviderRequestFailed";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.url = is.read_string()?;
                        },
                        16 => {
                            self.status_code = is.read_uint32()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.url.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.url);
                }
                if self.status_code != 0 {
                    my_size += ::protobuf::rt::uint32_size(2, self.status_code);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.url.is_empty() {
                    os.write_string(1, &self.url)?;
                }
                if self.status_code != 0 {
                    os.write_uint32(2, self.status_code)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ProviderRequestFailed {
                ProviderRequestFailed::new()
            }

            fn clear(&mut self) {
                self.url.clear();
                self.status_code = 0;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ProviderRequestFailed {
                static instance: ProviderRequestFailed = ProviderRequestFailed {
                    url: ::std::string::String::new(),
                    status_code: 0,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:fx.ipc.proto.Media.Error.ProviderParsingFailed)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ProviderParsingFailed {
            // message fields
            // @@protoc_insertion_point(field:fx.ipc.proto.Media.Error.ProviderParsingFailed.reason)
            pub reason: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:fx.ipc.proto.Media.Error.ProviderParsingFailed.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ProviderParsingFailed {
            fn default() -> &'a ProviderParsingFailed {
                <ProviderParsingFailed as ::protobuf::Message>::default_instance()
            }
        }

        impl ProviderParsingFailed {
            pub fn new() -> ProviderParsingFailed {
                ::std::default::Default::default()
            }
        }

        impl ::protobuf::Message for ProviderParsingFailed {
            const NAME: &'static str = "ProviderParsingFailed";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.reason = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.reason.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.reason);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.reason.is_empty() {
                    os.write_string(1, &self.reason)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ProviderParsingFailed {
                ProviderParsingFailed::new()
            }

            fn clear(&mut self) {
                self.reason.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ProviderParsingFailed {
                static instance: ProviderParsingFailed = ProviderParsingFailed {
                    reason: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:fx.ipc.proto.Media.Error.ProviderNotFound)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ProviderNotFound {
            // message fields
            // @@protoc_insertion_point(field:fx.ipc.proto.Media.Error.ProviderNotFound.provider_type)
            pub provider_type: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:fx.ipc.proto.Media.Error.ProviderNotFound.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ProviderNotFound {
            fn default() -> &'a ProviderNotFound {
                <ProviderNotFound as ::protobuf::Message>::default_instance()
            }
        }

        impl ProviderNotFound {
            pub fn new() -> ProviderNotFound {
                ::std::default::Default::default()
            }
        }

        impl ::protobuf::Message for ProviderNotFound {
            const NAME: &'static str = "ProviderNotFound";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.provider_type = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.provider_type.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.provider_type);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.provider_type.is_empty() {
                    os.write_string(1, &self.provider_type)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ProviderNotFound {
                ProviderNotFound::new()
            }

            fn clear(&mut self) {
                self.provider_type.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ProviderNotFound {
                static instance: ProviderNotFound = ProviderNotFound {
                    provider_type: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:fx.ipc.proto.Media.Error.Type)
        pub enum Type {
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Media.Error.Type.FAVORITES_LOADING_FAILED)
            FAVORITES_LOADING_FAILED = 0,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Media.Error.Type.FAVORITE_NOT_FOUND)
            FAVORITE_NOT_FOUND = 1,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Media.Error.Type.FAVORITE_ADD_FAILED)
            FAVORITE_ADD_FAILED = 2,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Media.Error.Type.WATCHED_LOADING_FAILED)
            WATCHED_LOADING_FAILED = 3,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Media.Error.Type.MEDIA_TYPE_NOT_SUPPORTED)
            MEDIA_TYPE_NOT_SUPPORTED = 4,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Media.Error.Type.NO_AVAILABLE_PROVIDERS)
            NO_AVAILABLE_PROVIDERS = 5,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Media.Error.Type.PROVIDER_CONNECTION_FAILED)
            PROVIDER_CONNECTION_FAILED = 6,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Media.Error.Type.PROVIDER_REQUEST_FAILED)
            PROVIDER_REQUEST_FAILED = 7,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Media.Error.Type.PROVIDER_ALREADY_EXISTS)
            PROVIDER_ALREADY_EXISTS = 8,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Media.Error.Type.PROVIDER_PARSING_FAILED)
            PROVIDER_PARSING_FAILED = 9,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Media.Error.Type.PROVIDER_NOT_FOUND)
            PROVIDER_NOT_FOUND = 10,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Media.Error.Type.PROVIDER_TIMEOUT)
            PROVIDER_TIMEOUT = 11,
            // @@protoc_insertion_point(enum_value:fx.ipc.proto.Media.Error.Type.AUTO_RESUME_LOADING_FAILED)
            AUTO_RESUME_LOADING_FAILED = 12,
        }

        impl ::protobuf::Enum for Type {
            const NAME: &'static str = "Type";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<Type> {
                match value {
                    0 => ::std::option::Option::Some(Type::FAVORITES_LOADING_FAILED),
                    1 => ::std::option::Option::Some(Type::FAVORITE_NOT_FOUND),
                    2 => ::std::option::Option::Some(Type::FAVORITE_ADD_FAILED),
                    3 => ::std::option::Option::Some(Type::WATCHED_LOADING_FAILED),
                    4 => ::std::option::Option::Some(Type::MEDIA_TYPE_NOT_SUPPORTED),
                    5 => ::std::option::Option::Some(Type::NO_AVAILABLE_PROVIDERS),
                    6 => ::std::option::Option::Some(Type::PROVIDER_CONNECTION_FAILED),
                    7 => ::std::option::Option::Some(Type::PROVIDER_REQUEST_FAILED),
                    8 => ::std::option::Option::Some(Type::PROVIDER_ALREADY_EXISTS),
                    9 => ::std::option::Option::Some(Type::PROVIDER_PARSING_FAILED),
                    10 => ::std::option::Option::Some(Type::PROVIDER_NOT_FOUND),
                    11 => ::std::option::Option::Some(Type::PROVIDER_TIMEOUT),
                    12 => ::std::option::Option::Some(Type::AUTO_RESUME_LOADING_FAILED),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<Type> {
                match str {
                    "FAVORITES_LOADING_FAILED" => ::std::option::Option::Some(Type::FAVORITES_LOADING_FAILED),
                    "FAVORITE_NOT_FOUND" => ::std::option::Option::Some(Type::FAVORITE_NOT_FOUND),
                    "FAVORITE_ADD_FAILED" => ::std::option::Option::Some(Type::FAVORITE_ADD_FAILED),
                    "WATCHED_LOADING_FAILED" => ::std::option::Option::Some(Type::WATCHED_LOADING_FAILED),
                    "MEDIA_TYPE_NOT_SUPPORTED" => ::std::option::Option::Some(Type::MEDIA_TYPE_NOT_SUPPORTED),
                    "NO_AVAILABLE_PROVIDERS" => ::std::option::Option::Some(Type::NO_AVAILABLE_PROVIDERS),
                    "PROVIDER_CONNECTION_FAILED" => ::std::option::Option::Some(Type::PROVIDER_CONNECTION_FAILED),
                    "PROVIDER_REQUEST_FAILED" => ::std::option::Option::Some(Type::PROVIDER_REQUEST_FAILED),
                    "PROVIDER_ALREADY_EXISTS" => ::std::option::Option::Some(Type::PROVIDER_ALREADY_EXISTS),
                    "PROVIDER_PARSING_FAILED" => ::std::option::Option::Some(Type::PROVIDER_PARSING_FAILED),
                    "PROVIDER_NOT_FOUND" => ::std::option::Option::Some(Type::PROVIDER_NOT_FOUND),
                    "PROVIDER_TIMEOUT" => ::std::option::Option::Some(Type::PROVIDER_TIMEOUT),
                    "AUTO_RESUME_LOADING_FAILED" => ::std::option::Option::Some(Type::AUTO_RESUME_LOADING_FAILED),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [Type] = &[
                Type::FAVORITES_LOADING_FAILED,
                Type::FAVORITE_NOT_FOUND,
                Type::FAVORITE_ADD_FAILED,
                Type::WATCHED_LOADING_FAILED,
                Type::MEDIA_TYPE_NOT_SUPPORTED,
                Type::NO_AVAILABLE_PROVIDERS,
                Type::PROVIDER_CONNECTION_FAILED,
                Type::PROVIDER_REQUEST_FAILED,
                Type::PROVIDER_ALREADY_EXISTS,
                Type::PROVIDER_PARSING_FAILED,
                Type::PROVIDER_NOT_FOUND,
                Type::PROVIDER_TIMEOUT,
                Type::AUTO_RESUME_LOADING_FAILED,
            ];
        }

        impl ::std::default::Default for Type {
            fn default() -> Self {
                Type::FAVORITES_LOADING_FAILED
            }
        }

    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:fx.ipc.proto.Media.Category)
    pub enum Category {
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Media.Category.MOVIES)
        MOVIES = 0,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Media.Category.SERIES)
        SERIES = 1,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.Media.Category.FAVORITES)
        FAVORITES = 3,
    }

    impl ::protobuf::Enum for Category {
        const NAME: &'static str = "Category";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Category> {
            match value {
                0 => ::std::option::Option::Some(Category::MOVIES),
                1 => ::std::option::Option::Some(Category::SERIES),
                3 => ::std::option::Option::Some(Category::FAVORITES),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Category> {
            match str {
                "MOVIES" => ::std::option::Option::Some(Category::MOVIES),
                "SERIES" => ::std::option::Option::Some(Category::SERIES),
                "FAVORITES" => ::std::option::Option::Some(Category::FAVORITES),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Category] = &[
            Category::MOVIES,
            Category::SERIES,
            Category::FAVORITES,
        ];
    }

    impl ::std::default::Default for Category {
        fn default() -> Self {
            Category::MOVIES
        }
    }

}

// @@protoc_insertion_point(message:fx.ipc.proto.GetMediaDetailsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetMediaDetailsRequest {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.GetMediaDetailsRequest.item)
    pub item: ::protobuf::MessageField<media::Item>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.GetMediaDetailsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetMediaDetailsRequest {
    fn default() -> &'a GetMediaDetailsRequest {
        <GetMediaDetailsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetMediaDetailsRequest {
    pub fn new() -> GetMediaDetailsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetMediaDetailsRequest {
    const NAME: &'static str = "GetMediaDetailsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.item)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetMediaDetailsRequest {
        GetMediaDetailsRequest::new()
    }

    fn clear(&mut self) {
        self.item.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetMediaDetailsRequest {
        static instance: GetMediaDetailsRequest = GetMediaDetailsRequest {
            item: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.GetMediaDetailsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetMediaDetailsResponse {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.GetMediaDetailsResponse.result)
    pub result: ::protobuf::EnumOrUnknown<super::message::response::Result>,
    // @@protoc_insertion_point(field:fx.ipc.proto.GetMediaDetailsResponse.item)
    pub item: ::protobuf::MessageField<media::Item>,
    // @@protoc_insertion_point(field:fx.ipc.proto.GetMediaDetailsResponse.error)
    pub error: ::protobuf::MessageField<media::Error>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.GetMediaDetailsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetMediaDetailsResponse {
    fn default() -> &'a GetMediaDetailsResponse {
        <GetMediaDetailsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetMediaDetailsResponse {
    pub fn new() -> GetMediaDetailsResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetMediaDetailsResponse {
    const NAME: &'static str = "GetMediaDetailsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.item)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.result != ::protobuf::EnumOrUnknown::new(super::message::response::Result::OK) {
            my_size += ::protobuf::rt::int32_size(1, self.result.value());
        }
        if let Some(v) = self.item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.result != ::protobuf::EnumOrUnknown::new(super::message::response::Result::OK) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.result))?;
        }
        if let Some(v) = self.item.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetMediaDetailsResponse {
        GetMediaDetailsResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::protobuf::EnumOrUnknown::new(super::message::response::Result::OK);
        self.item.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetMediaDetailsResponse {
        static instance: GetMediaDetailsResponse = GetMediaDetailsResponse {
            result: ::protobuf::EnumOrUnknown::from_i32(0),
            item: ::protobuf::MessageField::none(),
            error: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.GetMediaItemsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetMediaItemsRequest {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.GetMediaItemsRequest.category)
    pub category: ::protobuf::EnumOrUnknown<media::Category>,
    // @@protoc_insertion_point(field:fx.ipc.proto.GetMediaItemsRequest.genre)
    pub genre: ::protobuf::MessageField<media::Genre>,
    // @@protoc_insertion_point(field:fx.ipc.proto.GetMediaItemsRequest.sort_by)
    pub sort_by: ::protobuf::MessageField<media::SortBy>,
    // @@protoc_insertion_point(field:fx.ipc.proto.GetMediaItemsRequest.keywords)
    pub keywords: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:fx.ipc.proto.GetMediaItemsRequest.page)
    pub page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.GetMediaItemsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetMediaItemsRequest {
    fn default() -> &'a GetMediaItemsRequest {
        <GetMediaItemsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetMediaItemsRequest {
    pub fn new() -> GetMediaItemsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetMediaItemsRequest {
    const NAME: &'static str = "GetMediaItemsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.category = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.genre)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sort_by)?;
                },
                34 => {
                    self.keywords = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.category != ::protobuf::EnumOrUnknown::new(media::Category::MOVIES) {
            my_size += ::protobuf::rt::int32_size(1, self.category.value());
        }
        if let Some(v) = self.genre.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.sort_by.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.keywords.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.category != ::protobuf::EnumOrUnknown::new(media::Category::MOVIES) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.category))?;
        }
        if let Some(v) = self.genre.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.sort_by.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.keywords.as_ref() {
            os.write_string(4, v)?;
        }
        if self.page != 0 {
            os.write_uint32(5, self.page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetMediaItemsRequest {
        GetMediaItemsRequest::new()
    }

    fn clear(&mut self) {
        self.category = ::protobuf::EnumOrUnknown::new(media::Category::MOVIES);
        self.genre.clear();
        self.sort_by.clear();
        self.keywords = ::std::option::Option::None;
        self.page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetMediaItemsRequest {
        static instance: GetMediaItemsRequest = GetMediaItemsRequest {
            category: ::protobuf::EnumOrUnknown::from_i32(0),
            genre: ::protobuf::MessageField::none(),
            sort_by: ::protobuf::MessageField::none(),
            keywords: ::std::option::Option::None,
            page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.GetMediaItemsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetMediaItemsResponse {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.GetMediaItemsResponse.result)
    pub result: ::protobuf::EnumOrUnknown<super::message::response::Result>,
    // @@protoc_insertion_point(field:fx.ipc.proto.GetMediaItemsResponse.items)
    pub items: ::std::vec::Vec<media::Item>,
    // @@protoc_insertion_point(field:fx.ipc.proto.GetMediaItemsResponse.error)
    pub error: ::protobuf::MessageField<media::Error>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.GetMediaItemsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetMediaItemsResponse {
    fn default() -> &'a GetMediaItemsResponse {
        <GetMediaItemsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetMediaItemsResponse {
    pub fn new() -> GetMediaItemsResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetMediaItemsResponse {
    const NAME: &'static str = "GetMediaItemsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.result != ::protobuf::EnumOrUnknown::new(super::message::response::Result::OK) {
            my_size += ::protobuf::rt::int32_size(1, self.result.value());
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.result != ::protobuf::EnumOrUnknown::new(super::message::response::Result::OK) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.result))?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetMediaItemsResponse {
        GetMediaItemsResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::protobuf::EnumOrUnknown::new(super::message::response::Result::OK);
        self.items.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetMediaItemsResponse {
        static instance: GetMediaItemsResponse = GetMediaItemsResponse {
            result: ::protobuf::EnumOrUnknown::from_i32(0),
            items: ::std::vec::Vec::new(),
            error: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.ResetProviderApiRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResetProviderApiRequest {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.ResetProviderApiRequest.category)
    pub category: ::protobuf::EnumOrUnknown<media::Category>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.ResetProviderApiRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResetProviderApiRequest {
    fn default() -> &'a ResetProviderApiRequest {
        <ResetProviderApiRequest as ::protobuf::Message>::default_instance()
    }
}

impl ResetProviderApiRequest {
    pub fn new() -> ResetProviderApiRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ResetProviderApiRequest {
    const NAME: &'static str = "ResetProviderApiRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.category = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.category != ::protobuf::EnumOrUnknown::new(media::Category::MOVIES) {
            my_size += ::protobuf::rt::int32_size(1, self.category.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.category != ::protobuf::EnumOrUnknown::new(media::Category::MOVIES) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.category))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResetProviderApiRequest {
        ResetProviderApiRequest::new()
    }

    fn clear(&mut self) {
        self.category = ::protobuf::EnumOrUnknown::new(media::Category::MOVIES);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResetProviderApiRequest {
        static instance: ResetProviderApiRequest = ResetProviderApiRequest {
            category: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.GetCategoryGenresRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetCategoryGenresRequest {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.GetCategoryGenresRequest.category)
    pub category: ::protobuf::EnumOrUnknown<media::Category>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.GetCategoryGenresRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetCategoryGenresRequest {
    fn default() -> &'a GetCategoryGenresRequest {
        <GetCategoryGenresRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetCategoryGenresRequest {
    pub fn new() -> GetCategoryGenresRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetCategoryGenresRequest {
    const NAME: &'static str = "GetCategoryGenresRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.category = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.category != ::protobuf::EnumOrUnknown::new(media::Category::MOVIES) {
            my_size += ::protobuf::rt::int32_size(1, self.category.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.category != ::protobuf::EnumOrUnknown::new(media::Category::MOVIES) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.category))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetCategoryGenresRequest {
        GetCategoryGenresRequest::new()
    }

    fn clear(&mut self) {
        self.category = ::protobuf::EnumOrUnknown::new(media::Category::MOVIES);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetCategoryGenresRequest {
        static instance: GetCategoryGenresRequest = GetCategoryGenresRequest {
            category: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.GetCategoryGenresResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetCategoryGenresResponse {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.GetCategoryGenresResponse.result)
    pub result: ::protobuf::EnumOrUnknown<super::message::response::Result>,
    // @@protoc_insertion_point(field:fx.ipc.proto.GetCategoryGenresResponse.genres)
    pub genres: ::std::vec::Vec<media::Genre>,
    // @@protoc_insertion_point(field:fx.ipc.proto.GetCategoryGenresResponse.error)
    pub error: ::std::option::Option<::protobuf::EnumOrUnknown<get_category_genres_response::Error>>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.GetCategoryGenresResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetCategoryGenresResponse {
    fn default() -> &'a GetCategoryGenresResponse {
        <GetCategoryGenresResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetCategoryGenresResponse {
    pub fn new() -> GetCategoryGenresResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetCategoryGenresResponse {
    const NAME: &'static str = "GetCategoryGenresResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.genres.push(is.read_message()?);
                },
                24 => {
                    self.error = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.result != ::protobuf::EnumOrUnknown::new(super::message::response::Result::OK) {
            my_size += ::protobuf::rt::int32_size(1, self.result.value());
        }
        for value in &self.genres {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.result != ::protobuf::EnumOrUnknown::new(super::message::response::Result::OK) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.result))?;
        }
        for v in &self.genres {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.error {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetCategoryGenresResponse {
        GetCategoryGenresResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::protobuf::EnumOrUnknown::new(super::message::response::Result::OK);
        self.genres.clear();
        self.error = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetCategoryGenresResponse {
        static instance: GetCategoryGenresResponse = GetCategoryGenresResponse {
            result: ::protobuf::EnumOrUnknown::from_i32(0),
            genres: ::std::vec::Vec::new(),
            error: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `GetCategoryGenresResponse`
pub mod get_category_genres_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:fx.ipc.proto.GetCategoryGenresResponse.Error)
    pub enum Error {
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.GetCategoryGenresResponse.Error.INVALID_CATEGORY)
        INVALID_CATEGORY = 0,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.GetCategoryGenresResponse.Error.PROVIDER_NOT_FOUND)
        PROVIDER_NOT_FOUND = 1,
    }

    impl ::protobuf::Enum for Error {
        const NAME: &'static str = "Error";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Error> {
            match value {
                0 => ::std::option::Option::Some(Error::INVALID_CATEGORY),
                1 => ::std::option::Option::Some(Error::PROVIDER_NOT_FOUND),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Error> {
            match str {
                "INVALID_CATEGORY" => ::std::option::Option::Some(Error::INVALID_CATEGORY),
                "PROVIDER_NOT_FOUND" => ::std::option::Option::Some(Error::PROVIDER_NOT_FOUND),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Error] = &[
            Error::INVALID_CATEGORY,
            Error::PROVIDER_NOT_FOUND,
        ];
    }

    impl ::std::default::Default for Error {
        fn default() -> Self {
            Error::INVALID_CATEGORY
        }
    }

}

// @@protoc_insertion_point(message:fx.ipc.proto.GetCategorySortByRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetCategorySortByRequest {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.GetCategorySortByRequest.category)
    pub category: ::protobuf::EnumOrUnknown<media::Category>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.GetCategorySortByRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetCategorySortByRequest {
    fn default() -> &'a GetCategorySortByRequest {
        <GetCategorySortByRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetCategorySortByRequest {
    pub fn new() -> GetCategorySortByRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetCategorySortByRequest {
    const NAME: &'static str = "GetCategorySortByRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.category = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.category != ::protobuf::EnumOrUnknown::new(media::Category::MOVIES) {
            my_size += ::protobuf::rt::int32_size(1, self.category.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.category != ::protobuf::EnumOrUnknown::new(media::Category::MOVIES) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.category))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetCategorySortByRequest {
        GetCategorySortByRequest::new()
    }

    fn clear(&mut self) {
        self.category = ::protobuf::EnumOrUnknown::new(media::Category::MOVIES);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetCategorySortByRequest {
        static instance: GetCategorySortByRequest = GetCategorySortByRequest {
            category: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:fx.ipc.proto.GetCategorySortByResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetCategorySortByResponse {
    // message fields
    // @@protoc_insertion_point(field:fx.ipc.proto.GetCategorySortByResponse.result)
    pub result: ::protobuf::EnumOrUnknown<super::message::response::Result>,
    // @@protoc_insertion_point(field:fx.ipc.proto.GetCategorySortByResponse.sort_by)
    pub sort_by: ::std::vec::Vec<media::SortBy>,
    // @@protoc_insertion_point(field:fx.ipc.proto.GetCategorySortByResponse.error)
    pub error: ::std::option::Option<::protobuf::EnumOrUnknown<get_category_sort_by_response::Error>>,
    // special fields
    // @@protoc_insertion_point(special_field:fx.ipc.proto.GetCategorySortByResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetCategorySortByResponse {
    fn default() -> &'a GetCategorySortByResponse {
        <GetCategorySortByResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetCategorySortByResponse {
    pub fn new() -> GetCategorySortByResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetCategorySortByResponse {
    const NAME: &'static str = "GetCategorySortByResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.sort_by.push(is.read_message()?);
                },
                24 => {
                    self.error = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.result != ::protobuf::EnumOrUnknown::new(super::message::response::Result::OK) {
            my_size += ::protobuf::rt::int32_size(1, self.result.value());
        }
        for value in &self.sort_by {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.result != ::protobuf::EnumOrUnknown::new(super::message::response::Result::OK) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.result))?;
        }
        for v in &self.sort_by {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.error {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetCategorySortByResponse {
        GetCategorySortByResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::protobuf::EnumOrUnknown::new(super::message::response::Result::OK);
        self.sort_by.clear();
        self.error = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetCategorySortByResponse {
        static instance: GetCategorySortByResponse = GetCategorySortByResponse {
            result: ::protobuf::EnumOrUnknown::from_i32(0),
            sort_by: ::std::vec::Vec::new(),
            error: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `GetCategorySortByResponse`
pub mod get_category_sort_by_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:fx.ipc.proto.GetCategorySortByResponse.Error)
    pub enum Error {
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.GetCategorySortByResponse.Error.INVALID_CATEGORY)
        INVALID_CATEGORY = 0,
        // @@protoc_insertion_point(enum_value:fx.ipc.proto.GetCategorySortByResponse.Error.PROVIDER_NOT_FOUND)
        PROVIDER_NOT_FOUND = 1,
    }

    impl ::protobuf::Enum for Error {
        const NAME: &'static str = "Error";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Error> {
            match value {
                0 => ::std::option::Option::Some(Error::INVALID_CATEGORY),
                1 => ::std::option::Option::Some(Error::PROVIDER_NOT_FOUND),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Error> {
            match str {
                "INVALID_CATEGORY" => ::std::option::Option::Some(Error::INVALID_CATEGORY),
                "PROVIDER_NOT_FOUND" => ::std::option::Option::Some(Error::PROVIDER_NOT_FOUND),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Error] = &[
            Error::INVALID_CATEGORY,
            Error::PROVIDER_NOT_FOUND,
        ];
    }

    impl ::std::default::Default for Error {
        fn default() -> Self {
            Error::INVALID_CATEGORY
        }
    }

}
