use std::sync::Arc;
use std::sync::mpsc::{channel, Sender};

use log::{debug, error, info, trace, warn};
use tokio::runtime::Runtime;
use tokio::select;
use tokio::sync::Mutex;
use tokio_util::sync::CancellationToken;

use crate::core::{block_in_place, CallbackHandle, Callbacks, CoreCallback, CoreCallbacks, Handle};
use crate::core::loader::{LoadingCallback, LoadingData, LoadingError, LoadingEvent, LoadingHandle, LoadingResult, LoadingState};
use crate::core::loader::loading_chain::LoadingChain;

/// Represents a task responsible for loading media items in a playlist.
///
/// The `LoadingTask` manages loading processes, including handling loading events, canceling loading, and more.
#[derive(Debug)]
pub struct LoadingTask {
    inner: Arc<Mutex<Option<Arc<InnerLoadingTask>>>>,
}

impl LoadingTask {
    /// Creates a new `LoadingTask` instance.
    ///
    /// The task is associated with a loading chain and will manage loading processes for media items in the playlist.
    ///
    /// # Arguments
    ///
    /// * `chain` - An `Arc` to the loading chain containing loading strategies.
    /// * `runtime` - The [Runtime] instance to use for executing the loading task in the background.
    ///
    /// # Returns
    ///
    /// A new `LoadingTask` instance.
    pub fn new(chain: Arc<LoadingChain>, runtime: Arc<Runtime>) -> Self {
        let (tx, rx) = channel();
        let inner = Arc::new(Mutex::new(Some(Arc::new(InnerLoadingTask::new(chain, tx)))));
        let handle = block_in_place(inner.lock()).as_ref()
            .map(|e| e.handle())
            .unwrap_or(Handle::new());

        let event_inner = inner.clone();
        runtime.spawn(async move {
            let handle = block_in_place(event_inner.lock()).as_ref()
                .map(|e| e.handle())
                .unwrap_or(Handle::new());

            for event in rx {
                if let Some(e) = block_in_place(event_inner.lock()).as_ref() {
                    if let LoadingEvent::StateChanged(state) = &event {
                        e.handle_state_callback(state.clone());
                    }

                    e.callbacks.invoke(event);
                }
            }

            debug!("Shutting down loading task channel of {}", handle);
        });

        debug!("Creating new loading task {}", handle);
        Self {
            inner,
        }
    }

    /// Gets the handle associated with the loading task.
    ///
    /// The handle uniquely identifies the loading task.
    ///
    /// # Returns
    ///
    /// The loading task's handle.
    pub fn handle(&self) -> LoadingHandle {
        let mutex = block_in_place(self.inner.lock());
        mutex.as_ref()
            .map(|e| e.handle.clone())
            .unwrap_or(Handle::new())
    }

    /// Gets the current loading state of the task.
    ///
    /// # Returns
    ///
    /// The current loading state.
    pub fn state(&self) -> LoadingState {
        let mutex = block_in_place(self.inner.lock());
        mutex.as_ref().unwrap().state()
    }

    /// Asynchronously loads a media item using the task.
    ///
    /// This method initiates the loading process for a media item and returns the result.
    ///
    /// # Arguments
    ///
    /// * `data` - The `LoadingData` representing the media item to be loaded.
    ///
    /// # Returns
    ///
    /// A `Result` indicating the outcome of the loading operation. An error is returned if the loading process is canceled.
    pub async fn load(&self, data: LoadingData) -> Result<(), LoadingError> {
        let inner: Option<Arc<InnerLoadingTask>>;

        {
            let mutex = block_in_place(self.inner.lock());
            inner = mutex.as_ref().cloned();
        }

        if let Some(e) = inner {
            select! {
                _ = e.cancel_token.cancelled() => {
                    Err(LoadingError::Cancelled)
                },
                result = e.load(data) => {
                    result
                }
            }
        } else {
            panic!("Expected the inner loading task to still be available")
        }
    }

    /// Cancels the loading process associated with the task.
    ///
    /// This method cancels the loading process and any ongoing loading operation.
    pub fn cancel(&self) {
        if let Some(e) = block_in_place(self.inner.lock()).as_ref() {
            debug!("Cancelling loading task {}", e.handle());
            e.cancel_token.cancel()
        }
    }

    /// Subscribes to loading events with a callback function.
    ///
    /// This method registers a callback function to receive loading events generated by the loading task.
    ///
    /// # Arguments
    ///
    /// * `callback` - The callback function to handle loading events.
    ///
    /// # Returns
    ///
    /// A `CallbackHandle` representing the subscription to the loading events.
    pub fn subscribe(&self, callback: LoadingCallback) -> CallbackHandle {
        let mutex = block_in_place(self.inner.lock());
        mutex.as_ref()
            .unwrap()
            .subscribe(callback)
    }

    /// Unsubscribes from loading events using a callback handle.
    ///
    /// This method removes the callback function associated with the specified callback handle from receiving loading events.
    ///
    /// # Arguments
    ///
    /// * `callback_handle` - The `CallbackHandle` to unsubscribe.
    pub fn unsubscribe(&self, callback_handle: CallbackHandle) {
        if let Some(e) = block_in_place(self.inner.lock()).as_ref() {
            e.unsubscribe(callback_handle)
        }
    }
}

impl Drop for LoadingTask {
    fn drop(&mut self) {
        let _ = block_in_place(self.inner.lock()).take();
    }
}

#[derive(Debug)]
struct InnerLoadingTask {
    handle: Handle,
    cancel_token: CancellationToken,
    state: Mutex<LoadingState>,
    chain: Arc<LoadingChain>,
    sender_channel: Sender<LoadingEvent>,
    callbacks: CoreCallbacks<LoadingEvent>,
}

impl InnerLoadingTask {
    pub fn new(chain: Arc<LoadingChain>, sender_channel: Sender<LoadingEvent>) -> Self {
        Self {
            handle: Handle::new(),
            cancel_token: Default::default(),
            state: Mutex::new(LoadingState::Initializing),
            chain,
            sender_channel,
            callbacks: Default::default(),
        }
    }

    pub fn handle(&self) -> LoadingHandle {
        self.handle.clone()
    }

    pub fn state(&self) -> LoadingState {
        let mutex = block_in_place(self.state.lock());
        mutex.clone()
    }

    pub async fn load(&self, mut data: LoadingData) -> Result<(), LoadingError> {
        let strategies = self.chain.strategies();
        let mut index: i32 = 0;

        trace!("Processing a total of {} loading strategies for {}", strategies.len(), self.handle);
        self.handle_state_callback(LoadingState::Initializing);
        for strategy in strategies.iter() {
            if self.cancel_token.is_cancelled() {
                info!("Loading process is being cancelled");
                break;
            }

            if let Some(strategy) = strategy.upgrade() {
                index += 1;
                trace!("Executing {}", strategy);
                match strategy.process(data, self.sender_channel.clone(), self.cancel_token.clone()).await {
                    LoadingResult::Ok(updated_data) => data = updated_data,
                    LoadingResult::Completed => {
                        debug!("Loading strategies have been completed");
                        return Ok(());
                    }
                    LoadingResult::Err(err) => {
                        error!("An unexpected error occurred while loading playlist item, {}", err);
                        return Err(err);
                    }
                }
            } else {
                warn!("Loading strategy is no longer in scope");
            }
        }

        if self.cancel_token.is_cancelled() {
            debug!("Cancelling a total of {} loading strategies", index);
            while index >= 0 {
                if let Some(strategy) = strategies.get(index as usize)
                    .and_then(|e| e.upgrade()) {
                    trace!("Cancelling {}", strategy);
                    match strategy.cancel(data).await {
                        Ok(new_data) => data = new_data,
                        Err(e) => {
                            error!("Failed to cancel loading strategy, {}", e);
                            return Err(e);
                        }
                    }
                } else {
                    warn!("Unable to cancel loading strategy, strategy went out of scope");
                }

                index -= 1;
            }

            debug!("Finished cancelling loading task {}", self.handle);
            return Err(LoadingError::Cancelled);
        }

        Ok(())
    }

    pub fn subscribe(&self, callback: CoreCallback<LoadingEvent>) -> CallbackHandle {
        self.callbacks.add(callback)
    }

    pub fn unsubscribe(&self, callback_handle: CallbackHandle) {
        self.callbacks.remove(callback_handle)
    }

    pub fn handle_state_callback(&self, state: LoadingState) {
        let event_state = state.clone();
        {
            let mut mutex = block_in_place(self.state.lock());
            *mutex = state;
        }
        debug!("Loading task {} state changed to {}", self.handle, event_state);
        self.callbacks.invoke(LoadingEvent::StateChanged(event_state));
    }
}

#[cfg(test)]
mod tests {
    use std::thread;
    use std::time::Duration;

    use async_trait::async_trait;
    use derive_more::Display;

    use crate::core::loader::{CancellationResult, LoadingStrategy, MockLoadingStrategy};
    use crate::core::playlists::PlaylistItem;
    use crate::testing::init_logger;

    use super::*;

    #[derive(Debug, Display)]
    #[display(fmt = "CancelStrategy")]
    struct CancelStrategy {
        pub initiated: Sender<()>,
        pub cancelled: Sender<bool>,
    }

    #[async_trait]
    impl LoadingStrategy for CancelStrategy {
        async fn process(&self, _: LoadingData, _: Sender<LoadingEvent>, cancel: CancellationToken) -> LoadingResult {
            self.initiated.send(()).unwrap();
            while !cancel.is_cancelled() {
                thread::sleep(Duration::from_millis(50));
            }

            self.cancelled.send(true).unwrap();
            LoadingResult::Completed
        }

        async fn cancel(&self, data: LoadingData) -> CancellationResult {
            CancellationResult::Ok(data)
        }
    }

    #[test]
    fn test_handle() {
        init_logger();
        let runtime = Arc::new(Runtime::new().unwrap());
        let task = LoadingTask::new(Arc::new(LoadingChain::from(vec![])), runtime.clone());

        assert_ne!(task.handle().value(), 0i64);
    }

    #[test]
    fn test_state() {
        init_logger();
        let data = LoadingData::from(PlaylistItem {
            url: None,
            title: "MyStateTest".to_string(),
            caption: None,
            thumb: None,
            parent_media: None,
            media: None,
            torrent_info: None,
            torrent_file_info: None,
            quality: None,
            auto_resume_timestamp: None,
            subtitles_enabled: false,
        });
        let (tx, rx) = channel();
        let mut strategy = MockLoadingStrategy::new();
        strategy.expect_process()
            .times(1)
            .returning(move |_, callback, _| {
                callback.send(LoadingEvent::StateChanged(LoadingState::Downloading)).unwrap();
                LoadingResult::Completed
            });
        let runtime = Arc::new(Runtime::new().unwrap());
        let task = Arc::new(LoadingTask::new(Arc::new(LoadingChain::from(vec![Box::new(strategy) as Box<dyn LoadingStrategy>])), runtime.clone()));
        let runtime = Runtime::new().unwrap();

        task.subscribe(Box::new(move |event| {
            if let LoadingEvent::StateChanged(state) = event {
                // the first event is always initializing, so ignore it
                if state != LoadingState::Initializing {
                    tx.send(state).unwrap();
                }
            }
        }));

        let del_task = task.clone();
        runtime.spawn(async move {
            let _ = del_task.load(data).await;
        });

        let result = rx.recv_timeout(Duration::from_millis(200)).unwrap();
        assert_eq!(LoadingState::Downloading, result);
    }

    #[test]
    fn test_load() {
        init_logger();
        let data = LoadingData::from(PlaylistItem {
            url: None,
            title: "MyLoadTest".to_string(),
            caption: None,
            thumb: None,
            parent_media: None,
            media: None,
            torrent_info: None,
            torrent_file_info: None,
            quality: None,
            auto_resume_timestamp: None,
            subtitles_enabled: false,
        });
        let (tx_data, rx_data) = channel();
        let (tx_event, rx_event) = channel();
        let mut strategy = MockLoadingStrategy::new();
        strategy.expect_process()
            .times(1)
            .returning(move |data, _, _| {
                tx_data.send(data).unwrap();
                LoadingResult::Completed
            });
        let runtime = Arc::new(Runtime::new().unwrap());
        let task = LoadingTask::new(Arc::new(LoadingChain::from(vec![Box::new(strategy) as Box<dyn LoadingStrategy>])), runtime.clone());

        task.subscribe(Box::new(move |e| {
            tx_event.send(e).unwrap();
        }));

        let result = block_in_place(task.load(data.clone()));
        assert_eq!(Ok(()), result);

        let result = rx_data.recv_timeout(Duration::from_millis(200)).unwrap();
        assert_eq!(data, result);

        let result = rx_event.recv_timeout(Duration::from_millis(200)).unwrap();
        assert_eq!(LoadingEvent::StateChanged(LoadingState::Initializing), result);
    }

    #[test]
    fn test_cancel_should_return_cancelled_error() {
        init_logger();
        let data = LoadingData::from(PlaylistItem {
            url: None,
            title: "".to_string(),
            caption: None,
            thumb: None,
            parent_media: None,
            media: None,
            torrent_info: None,
            torrent_file_info: None,
            quality: None,
            auto_resume_timestamp: None,
            subtitles_enabled: false,
        });
        let mut strategy = MockLoadingStrategy::new();
        let (tx, rx) = channel();
        strategy.expect_process()
            .returning(move |_, _, _| {
                thread::sleep(Duration::from_secs(20));
                LoadingResult::Completed
            });
        strategy.expect_cancel()
            .returning(|data| CancellationResult::Ok(data));
        let runtime = Arc::new(Runtime::new().unwrap());
        let task = Arc::new(LoadingTask::new(Arc::new(LoadingChain::from(vec![Box::new(strategy) as Box<dyn LoadingStrategy>])), runtime.clone()));
        let runtime = Runtime::new().unwrap();

        let del_task = task.clone();
        runtime.spawn(async move {
            let result = del_task.load(data).await;
            tx.send(result).unwrap();
        });

        task.cancel();
        let result = rx.recv_timeout(Duration::from_millis(200)).unwrap();
        assert_eq!(Err(LoadingError::Cancelled), result);
    }

    #[test]
    fn test_cancel_should_cancel_strategy_token() {
        init_logger();
        let data = LoadingData::from(PlaylistItem {
            url: None,
            title: "".to_string(),
            caption: None,
            thumb: None,
            parent_media: None,
            media: None,
            torrent_info: None,
            torrent_file_info: None,
            quality: None,
            auto_resume_timestamp: None,
            subtitles_enabled: false,
        });
        let (tx, rx) = channel();
        let (tx_cancelled, rx_cancelled) = channel();
        let strategy = CancelStrategy {
            initiated: tx,
            cancelled: tx_cancelled,
        };
        let runtime = Arc::new(Runtime::new().unwrap());
        let task = Arc::new(LoadingTask::new(Arc::new(LoadingChain::from(vec![Box::new(strategy) as Box<dyn LoadingStrategy>])), runtime.clone()));
        let runtime = Runtime::new().unwrap();

        let del_task = task.clone();
        runtime.spawn(async move {
            let _ = del_task.load(data).await;
        });

        let _ = rx.recv_timeout(Duration::from_millis(200)).expect("expected the strategy process to have been started");
        task.cancel();
        let result = rx_cancelled.recv_timeout(Duration::from_millis(200)).unwrap();
        assert!(result, "expected the strategy to have been cancelled");
    }

    #[test]
    fn test_cancel_should_call_cancel_when_executed() {
        init_logger();
        let data = LoadingData::from(PlaylistItem {
            url: None,
            title: "".to_string(),
            caption: None,
            thumb: None,
            parent_media: None,
            media: None,
            torrent_info: None,
            torrent_file_info: None,
            quality: None,
            auto_resume_timestamp: None,
            subtitles_enabled: false,
        });
        let (tx, rx) = channel();
        let (tx_cancel, rx_cancel) = channel();
        let mut strat1 = MockLoadingStrategy::new();
        strat1.expect_process()
            .times(1)
            .returning(move |e, _, _| {
                tx.send(()).unwrap();
                LoadingResult::Ok(e)
            });
        strat1.expect_cancel()
            .times(1)
            .returning(move |e| {
                tx_cancel.send(e.clone()).unwrap();
                CancellationResult::Ok(e)
            });
        let mut strat2 = MockLoadingStrategy::new();
        strat2.expect_process()
            .times(1)
            .returning(|data, _, _| {
                thread::sleep(Duration::from_millis(200));
                LoadingResult::Ok(data)
            });
        strat2.expect_cancel()
            .returning(|e| {
                CancellationResult::Ok(e)
            });
        let runtime = Arc::new(Runtime::new().unwrap());
        let task = Arc::new(LoadingTask::new(Arc::new(LoadingChain::from(vec![
            Box::new(strat1) as Box<dyn LoadingStrategy>,
            Box::new(strat2) as Box<dyn LoadingStrategy>,
        ])), runtime.clone()));
        let runtime = Runtime::new().unwrap();

        let del_task = task.clone();
        let data_copy = data.clone();
        runtime.spawn(async move {
            let _ = del_task.load(data_copy).await;
        });

        let _ = rx.recv_timeout(Duration::from_millis(200)).expect("expected the strategy process to have been started");
        task.cancel();
        let result = rx_cancel.recv_timeout(Duration::from_millis(500)).expect("expected the cancel fn to have been invoked");
        assert_eq!(data, result);
    }
}